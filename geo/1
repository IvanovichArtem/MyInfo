{
  "cells": [
    {
      "cell_type": "markdown",
      "id": "8bc7575b",
      "metadata": {},
      "source": [
        "# Imports\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "35f7ef9b",
      "metadata": {},
      "outputs": [],
      "source": [
        "import pandas as pd\n",
        "import numpy as np\n",
        "import os\n",
        "from scipy import stats\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "import warnings\n",
        "import re\n",
        "import shap\n",
        "from tqdm import tqdm\n",
        "from lightgbm import early_stopping, log_evaluation\n",
        "\n",
        "pd.set_option(\"display.max_columns\", None)\n",
        "pd.set_option(\"display.max_rows\", 100)\n",
        "\n",
        "sns.set(style=\"whitegrid\")\n",
        "\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "\n",
        "from catboost import CatBoostRegressor, Pool\n",
        "from xgboost import XGBRegressor\n",
        "from lightgbm import LGBMRegressor\n",
        "from sklearn.ensemble import RandomForestRegressor\n",
        "\n",
        "from sklearn.compose import ColumnTransformer\n",
        "from sklearn.preprocessing import OneHotEncoder\n",
        "from sklearn.model_selection import train_test_split\n",
        "from sklearn.metrics import (\n",
        "    mean_squared_error,\n",
        "    mean_absolute_error,\n",
        "    r2_score,\n",
        "    root_mean_squared_error,\n",
        "    mean_absolute_percentage_error,\n",
        ")\n",
        "import pickle\n",
        "\n",
        "warnings.filterwarnings(\"ignore\")"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "ee6bccd8",
      "metadata": {},
      "source": [
        "# Utils\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b0b926a5",
      "metadata": {},
      "outputs": [],
      "source": [
        "from lightgbm.callback import CallbackEnv, EarlyStopException\n",
        "import logging\n",
        "\n",
        "\n",
        "class SimpleGapStopping:\n",
        "    \"\"\"Останавливает обучение сразу при превышении порога разницы\"\"\"\n",
        "\n",
        "    def __init__(self, metric_name=\"rmse\", gap_threshold=3.0, verbose=True):\n",
        "        self.metric_name = metric_name\n",
        "        self.gap_threshold = gap_threshold\n",
        "        self.verbose = verbose\n",
        "        self.order = 20\n",
        "        self.before_iteration = False\n",
        "        self.logger = logging.getLogger(\"LightGBM\")\n",
        "\n",
        "        # Сохраняем предыдущие значения для отслеживания тренда\n",
        "        self.prev_train_metric = None\n",
        "        self.prev_valid_metric = None\n",
        "\n",
        "    def __call__(self, env: CallbackEnv):\n",
        "        if env.evaluation_result_list is None:\n",
        "            return\n",
        "\n",
        "        # Ищем метрики\n",
        "        train_metric, valid_metric = None, None\n",
        "        # print(env.evaluation_result_list)\n",
        "        for result in env.evaluation_result_list:\n",
        "            if len(result) >= 3:\n",
        "                dataset_name, metric_name, metric_value = result[:3]\n",
        "                if metric_name == self.metric_name:\n",
        "                    if \"train\" in dataset_name.lower():\n",
        "                        train_metric = metric_value\n",
        "                    elif \"valid\" in dataset_name.lower():\n",
        "                        valid_metric = metric_value\n",
        "\n",
        "        if train_metric and valid_metric:\n",
        "            gap_ratio = valid_metric / train_metric\n",
        "\n",
        "            # Логируем прогресс каждые 100 итераций\n",
        "            if self.verbose and env.iteration % 100 == 0:\n",
        "                trend = \"\"\n",
        "                if self.prev_train_metric and self.prev_valid_metric:\n",
        "                    train_trend = (\n",
        "                        \"↘\" if train_metric < self.prev_train_metric else \"↗\"\n",
        "                    )\n",
        "                    valid_trend = (\n",
        "                        \"↘\" if valid_metric < self.prev_valid_metric else \"↗\"\n",
        "                    )\n",
        "                    gap_trend = (\n",
        "                        \"↘\"\n",
        "                        if gap_ratio\n",
        "                        < (self.prev_valid_metric / self.prev_train_metric)\n",
        "                        else \"↗\"\n",
        "                    )\n",
        "                    trend = f\" Trend: Train{train_trend} Valid{valid_trend} Gap{gap_trend}\"\n",
        "\n",
        "                print(\n",
        "                    f\"Iter {env.iteration:4d}: {self.metric_name.upper()} - \"\n",
        "                    f\"Train: {train_metric:8.4f}, Valid: {valid_metric:8.4f}, \"\n",
        "                    f\"Gap: {gap_ratio:5.2f}x{trend}\"\n",
        "                )\n",
        "\n",
        "            # Сохраняем текущие значения для следующей итерации\n",
        "            self.prev_train_metric = train_metric\n",
        "            self.prev_valid_metric = valid_metric\n",
        "\n",
        "            # Проверяем условие остановки\n",
        "            if gap_ratio > self.gap_threshold:\n",
        "                if self.verbose:\n",
        "                    print(\n",
        "                        f\"Early stopping triggered at iteration {env.iteration}!\\n\"\n",
        "                        f\"Reason: Gap ratio {gap_ratio:.2f}x exceeds threshold {self.gap_threshold}x\\n\"\n",
        "                        f\"Final metrics - Train {self.metric_name}: {train_metric:.4f}, \"\n",
        "                        f\"Valid {self.metric_name}: {valid_metric:.4f}\"\n",
        "                    )\n",
        "                raise EarlyStopException(\n",
        "                    env.iteration - 1, env.evaluation_result_list\n",
        "                )"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "0fc1b020",
      "metadata": {},
      "outputs": [],
      "source": [
        "def add_date_features(\n",
        "    df: pd.DataFrame,\n",
        "    date_col: str = \"deal_date\",\n",
        "    dayfirst: bool = True,\n",
        ") -> pd.DataFrame:\n",
        "    \"\"\"\n",
        "    Преобразует столбец с датой во временной тип и добавляет набор удобных фичей.\n",
        "    Ничего не перезаписывает, создаёт новый столбец <date_col>_dt и фичи.\n",
        "    \"\"\"\n",
        "    out = df.copy()\n",
        "\n",
        "    # Приводим к datetime (бережно к пропускам)\n",
        "    dt = pd.to_datetime(out[date_col], errors=\"coerce\", dayfirst=dayfirst)\n",
        "\n",
        "    # Базовые компоненты\n",
        "    out[\"year\"] = dt.dt.year\n",
        "    out[\"quarter\"] = dt.dt.quarter\n",
        "    out[\"month\"] = dt.dt.month\n",
        "    out[\"day\"] = dt.dt.day\n",
        "    out[\"dayofweek\"] = dt.dt.dayofweek  # 0=Mon..6=Sun\n",
        "    out[\"is_weekend\"] = out[\"dayofweek\"].isin([5, 6]).astype(\"int8\")\n",
        "    out[\"week\"] = dt.dt.isocalendar().week.astype(\"int16\")\n",
        "    out[\"dayofyear\"] = dt.dt.dayofyear\n",
        "    out[\"is_month_start\"] = dt.dt.is_month_start.astype(\"int8\")\n",
        "    out[\"is_month_end\"] = dt.dt.is_month_end.astype(\"int8\")\n",
        "    out[\"is_quarter_start\"] = dt.dt.is_quarter_start.astype(\"int8\")\n",
        "    out[\"is_quarter_end\"] = dt.dt.is_quarter_end.astype(\"int8\")\n",
        "    out[\"is_year_start\"] = dt.dt.is_year_start.astype(\"int8\")\n",
        "    out[\"is_year_end\"] = dt.dt.is_year_end.astype(\"int8\")\n",
        "\n",
        "    # Сезон (зима=1, весна=2, лето=3, осень=4; можно переименовать как нужно)\n",
        "    def month_to_season(m):\n",
        "        if m in (12, 1, 2):\n",
        "            return 1\n",
        "        if m in (3, 4, 5):\n",
        "            return 2\n",
        "        if m in (6, 7, 8):\n",
        "            return 3\n",
        "        return 4\n",
        "\n",
        "    out[\"season\"] = out[\"month\"].map(month_to_season).astype(\"int8\")\n",
        "\n",
        "    # Циклические кодировки — часто помогают моделям\n",
        "    # месяц\n",
        "    out[\"month_sin\"] = np.sin(2 * np.pi * out[\"month\"] / 12)\n",
        "    out[\"month_cos\"] = np.cos(2 * np.pi * out[\"month\"] / 12)\n",
        "    # день недели\n",
        "    out[\"dow_sin\"] = np.sin(2 * np.pi * out[\"dayofweek\"] / 7)\n",
        "    out[\"dow_cos\"] = np.cos(2 * np.pi * out[\"dayofweek\"] / 7)\n",
        "\n",
        "    # Относительные фичи — сколько дней с начала данных / с минимальной даты\n",
        "    origin = dt.min()\n",
        "    out[\"days_since_min\"] = (dt - origin).dt.total_seconds() / (24 * 3600)\n",
        "\n",
        "    return out"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d0b6fafb",
      "metadata": {},
      "outputs": [],
      "source": [
        "# ====== Метрики ======\n",
        "def smape_metric(y_true, y_pred, eps=1e-9):\n",
        "    y_true = np.asarray(y_true)\n",
        "    y_pred = np.asarray(y_pred)\n",
        "    denom = np.abs(y_true) + np.abs(y_pred) + eps\n",
        "    return 100.0 * np.mean(2.0 * np.abs(y_pred - y_true) / denom)\n",
        "\n",
        "\n",
        "def mdape_metric(y_true, y_pred, eps=1e-8):\n",
        "    y_true = np.asarray(y_true)\n",
        "    y_pred = np.asarray(y_pred)\n",
        "    denom = np.where(np.abs(y_true) < eps, eps, np.abs(y_true))\n",
        "    ape = np.abs(y_true - y_pred) / denom\n",
        "    return np.median(ape) * 100.0\n",
        "\n",
        "\n",
        "def compute_metrics(y_true_orig, y_pred_orig):\n",
        "    rmse = root_mean_squared_error(y_true_orig, y_pred_orig)\n",
        "    mae = mean_absolute_error(y_true_orig, y_pred_orig)\n",
        "    mse = mean_squared_error(y_true_orig, y_pred_orig)\n",
        "    r2 = r2_score(y_true_orig, y_pred_orig)\n",
        "    mape = 100.0 * mean_absolute_percentage_error(y_true_orig, y_pred_orig)\n",
        "    mdape = mdape_metric(y_true_orig, y_pred_orig)\n",
        "    smape = smape_metric(y_true_orig, y_pred_orig)\n",
        "    return {\n",
        "        \"rmse\": rmse,\n",
        "        \"mse\": mse,\n",
        "        \"mae\": mae,\n",
        "        \"r2\": r2,\n",
        "        \"mape_%\": mape,\n",
        "        \"median_mape_%\": mdape,\n",
        "        \"smape_%\": smape,\n",
        "    }"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "baa7efbe",
      "metadata": {},
      "source": [
        "# Load\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b4af10c4",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = pd.read_csv(\"./data/clean_full_df.csv\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b259f86a",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.columns"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "81c51bab",
      "metadata": {},
      "outputs": [],
      "source": [
        "missing_pct = (\n",
        "    (df.isna().mean()[lambda s: s > 0.5] * 100)\n",
        "    .round(2)\n",
        "    .sort_values(ascending=False)\n",
        ")\n",
        "print((missing_pct.astype(str) + \"%\"))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "cc9204bc",
      "metadata": {},
      "outputs": [],
      "source": [
        "drop_columns = [\n",
        "    \"USD\",  # столбцы из 3 пункта обработки\n",
        "    \"BYN\",\n",
        "    \"EUR\",\n",
        "    \"Форма_BYN\",\n",
        "    \"Форма_EUR\",\n",
        "    \"Форма_USD\",\n",
        "    \"Логика извлечения\",\n",
        "    \"sheet_source\",\n",
        "    \"search_param\",\n",
        "    \"Дата\",\n",
        "    \"rules_5\",\n",
        "    \"rules_6\",\n",
        "    \"п/п\",  # ненужные столбцы (лишний, использовались для заполнения других столбцов)\n",
        "]\n",
        "missing_info_drop_columns = list(df.columns[df.isna().mean() > 0.8])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "2b480ce0",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(df.shape)\n",
        "df.drop(columns=drop_columns, errors=\"ignore\", inplace=True)\n",
        "print(df.shape)\n",
        "df.drop(columns=missing_info_drop_columns, errors=\"ignore\", inplace=True)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "cb568bec",
      "metadata": {},
      "outputs": [],
      "source": [
        "missing_pct = (\n",
        "    (df.isna().mean()[lambda s: s >= 0] * 100)\n",
        "    .round(2)\n",
        "    .sort_values(ascending=False)\n",
        ")\n",
        "print((missing_pct.astype(str) + \"%\"))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f1dd898d",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"Цена в долларах США за кв.м\"] = (\n",
        "    df[\"Цена в долларах США\"] / df[\"Общая площадь, кв.м\"]\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "4e637cfb",
      "metadata": {},
      "outputs": [],
      "source": [
        "# убираем бел рубли и евро, т.к. предсказывать будем цену за кв. м. в долларах сша\n",
        "df.drop(\n",
        "    columns=[\n",
        "        \"Цена в бел. руб.\",\n",
        "        \"Цена в евро\",\n",
        "        \"Цена в долларах США\",\n",
        "        \"Цена в бел. руб. за кв.м\",\n",
        "        \"Цена в евро за кв.м\",\n",
        "        \"Цена по договору\",\n",
        "        \"Валюта по договору\",\n",
        "    ],\n",
        "    inplace=True,\n",
        "    errors=\"ignore\",\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "cf33495d",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.head(2)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "2dedd7af",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.drop(\n",
        "    columns=[\n",
        "        \"Описание назначения\",  # много уникальных значений, строки\n",
        "        \"Наименование\",\n",
        "        \"Дата ввода\",  # повтор столбца Дата сделки\n",
        "        \"Идентификатор сделки\",  # ненужный уникальный идентификатор\n",
        "        \"Адрес\",  # много уникальных значений, инфа уже передана в другие фичи\n",
        "        \"Описание цены\",  # оттуда уже распарсили инфу\n",
        "        \"Тип цены\",  #  всего 1 уникальное значение\n",
        "        \"Инвентарный номер КС\",  # идентификатор\n",
        "        \"Назначение КС\",\n",
        "        \"Описание назначения КС\",\n",
        "        \"Наименование КС\",\n",
        "        \"Составные элементы и принадлежности\",\n",
        "        \"Кадастровый номер ЗУ\",  # еще один идентификатор\n",
        "        \"Описание назначения ЗУ\",\n",
        "        \"Уникальный номер АТЕ\",  # еще один идентификатор\n",
        "    ],\n",
        "    inplace=True,\n",
        "    errors=\"ignore\",\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d95b3a45",
      "metadata": {},
      "outputs": [],
      "source": [
        "def conv_date(x):\n",
        "    if pd.isna(x):\n",
        "        return pd.NaT\n",
        "    s = str(x).strip()\n",
        "    for fmt in (\"%Y-%m-%d %H:%M:%S\", \"%d.%m.%Y\", \"%Y-%m-%d\"):\n",
        "        try:\n",
        "            return pd.to_datetime(s, format=fmt)\n",
        "        except ValueError:\n",
        "            pass\n",
        "    return pd.NaT"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b291a516",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"Дата сделки\"] = df[\"Дата сделки\"].apply(conv_date)\n",
        "df[\"Дата регистрации договора\"] = df[\"Дата регистрации договора\"].apply(\n",
        "    conv_date\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "71d2af08",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.columns"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "79fd122e",
      "metadata": {},
      "outputs": [],
      "source": [
        "rename_map = {\n",
        "    \"Тип недвижимого имущества\": \"property_type\",\n",
        "    \"Инвентарный номер\": \"inventory_id\",\n",
        "    \"Назначение\": \"purpose\",\n",
        "    \"Общая площадь, кв.м\": \"area_total_m2\",\n",
        "    \"Материал стен\": \"wall_material\",\n",
        "    \"Дата сделки\": \"deal_date\",\n",
        "    \"Дата регистрации договора\": \"contract_reg_date\",\n",
        "    \"Количество объектов в сделке\": \"deal_objects_count\",\n",
        "    \"Цена в долларах США за кв.м\": \"price_usd_per_m2\",\n",
        "    \"Переходящая доля\": \"transferred_share\",\n",
        "    \"Этаж расположения ИП\": \"unit_floor\",\n",
        "    \"Общая площадь КС, кв.м\": \"ks_area_total_m2\",\n",
        "    \"Процент готовности КС\": \"ks_completion_pct\",\n",
        "    \"Количество надземных этажей, шт.\": \"floors_above\",\n",
        "    \"Количество подземных этажей, шт.\": \"floors_below\",\n",
        "    \"Назначение ЗУ\": \"land_use\",\n",
        "    \"Площадь ЗУ, кв.м\": \"land_area_m2\",\n",
        "    \"Маркеры\": \"markers\",\n",
        "    \"Распределение долей до сделки\": \"shares_before\",\n",
        "    \"Распределение долей после сделки\": \"shares_after\",\n",
        "    \"1 Евро (EUR)\": \"eur_rate\",\n",
        "    \"1 Российский рубль (RUB)\": \"rub_rate\",\n",
        "    \"1 Доллар США (USD)\": \"usd_rate\",\n",
        "    \"Name region\": \"region_name\",\n",
        "    \"Name oblast\": \"oblast_name\",\n",
        "}\n",
        "df = df.rename(columns=rename_map)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "cdfd265a",
      "metadata": {},
      "source": [
        "# EDA\n"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "0352564c",
      "metadata": {},
      "source": [
        "## price_usd_per_m2\n",
        "\n",
        "Данный столбец это таргет\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d5d3eeb0",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(df[\"price_usd_per_m2\"].isna().sum())\n",
        "df[\"price_usd_per_m2\"].dropna(inplace=True)\n",
        "\n",
        "print(\"inf values count\", (df[\"price_usd_per_m2\"] == np.inf).sum())\n",
        "display(df[df[\"price_usd_per_m2\"] == np.inf].head())\n",
        "df = df[df[\"price_usd_per_m2\"] != np.inf]\n",
        "df[\"price_usd_per_m2\"] = df[\"price_usd_per_m2\"].round(2)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "dd870799",
      "metadata": {},
      "outputs": [],
      "source": [
        "target_col = \"price_usd_per_m2\""
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "df7d2322",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(f\"=== Таргет: {target_col} ===\")\n",
        "print(f\"Всего наблюдений: {df[target_col].size}\")\n",
        "print(f\"Пропусков: {df[target_col].isna().sum()}\")\n",
        "\n",
        "n_le0 = (df[target_col] <= 0).sum()\n",
        "n_eq0 = (df[target_col] == 0).sum()\n",
        "n_neg = (df[target_col] < 0).sum()\n",
        "print(f\"<= 0: {n_le0} | = 0: {n_eq0} | < 0: {n_neg}\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "a4355dfd",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(df.shape)\n",
        "df = df[df[target_col] > 0]\n",
        "print(df.shape)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "85c70079",
      "metadata": {},
      "outputs": [],
      "source": [
        "desc = df[target_col].describe(\n",
        "    percentiles=[0.01, 0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95, 0.99]\n",
        ")\n",
        "display(desc.to_frame(\"value\"))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5977f732",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[df[target_col] > 1800][target_col].sort_values()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "68ea0d5c",
      "metadata": {},
      "outputs": [],
      "source": [
        "skew = stats.skew(df[target_col], bias=False)\n",
        "kurt = stats.kurtosis(df[target_col], fisher=True, bias=False)\n",
        "print(f\"Skewness: {skew:.3f} | Kurtosis(Fisher): {kurt:.3f}\")\n",
        "\n",
        "q1, q3 = np.percentile(df[target_col], [25, 75])\n",
        "iqr = q3 - q1\n",
        "low_whisk = q1 - 1.5 * iqr\n",
        "high_whisk = q3 + 1.5 * iqr\n",
        "print(f\"IQR: {iqr:.3f} | границы: [{low_whisk:.3f}, {high_whisk:.3f}]\")\n",
        "print(\n",
        "    f\"Выбросы ниже: {(df[target_col] < low_whisk).sum()} | выше: {(df[target_col] > high_whisk).sum()}\"\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "11986efb",
      "metadata": {},
      "outputs": [],
      "source": [
        "ax = sns.histplot(df[target_col], bins=100, kde=True)\n",
        "ax.set_title(f\"{target_col}: распределение\")\n",
        "ax.set_xlabel(target_col)\n",
        "ax.set_ylabel(\"count\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "3d68d471",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 3.2))\n",
        "sns.boxplot(x=df[target_col], ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col}: boxplot\")\n",
        "axes[0].set_xlabel(target_col)\n",
        "sns.violinplot(x=df[target_col], ax=axes[1], inner=\"quartile\", cut=0)\n",
        "axes[1].set_title(f\"{target_col}: violin\")\n",
        "axes[1].set_xlabel(target_col)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "4a018d37",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(df.shape, high_whisk, desc[\"1%\"])\n",
        "df = df[~(df[target_col] > high_whisk)]\n",
        "print(\"After delete > high whisk\", df.shape)\n",
        "# df = df[df[target_col] > desc[\"1%\"]]\n",
        "print(df.shape)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "882a7a74",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[target_col].sort_values()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "baeb5e80",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[df[target_col] < 1].shape"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "01ca9e9e",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(14, 5))\n",
        "\n",
        "# Гистограмма до обрезки\n",
        "sns.histplot(df[target_col], bins=100, kde=True, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} до обрезки\")\n",
        "axes[0].set_xlabel(target_col)\n",
        "axes[0].set_ylabel(\"count\")\n",
        "\n",
        "# Гистограмма после обрезки\n",
        "sns.histplot(\n",
        "    df[~(df[target_col] > high_whisk)][target_col],\n",
        "    bins=100,\n",
        "    kde=True,\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"{target_col} после обрезки\")\n",
        "axes[1].set_xlabel(target_col)\n",
        "axes[1].set_ylabel(\"count\")\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "65459831",
      "metadata": {},
      "outputs": [],
      "source": [
        "ax = sns.histplot(df[target_col], bins=100, kde=True)\n",
        "ax.set_title(f\"{target_col}: распределение\")\n",
        "ax.set_xlabel(target_col)\n",
        "ax.set_ylabel(\"count\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "84401000",
      "metadata": {},
      "outputs": [],
      "source": [
        "s_log = np.log1p(df[target_col])\n",
        "ax = sns.histplot(s_log, bins=60, kde=True)\n",
        "ax.set_title(f\"log1p({target_col}): распределение\")\n",
        "ax.set_xlabel(f\"log1p({target_col})\")\n",
        "ax.set_ylabel(\"count\")\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "\n",
        "skew_log = stats.skew(s_log, bias=False)\n",
        "kurt_log = stats.kurtosis(s_log, fisher=True, bias=False)\n",
        "print(f\"После log1p -> Skew: {skew_log:.3f} | Kurtosis: {kurt_log:.3f}\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "ccce5cdd",
      "metadata": {},
      "outputs": [],
      "source": [
        "log_target_col = f\"log1p_{target_col}\"\n",
        "df[log_target_col] = df[target_col].apply(np.log1p)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "8168b090",
      "metadata": {},
      "source": [
        "Сильный правый хвост, попробуем обучить с лог-шкалой и без, а потом проверим метрики\n"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c1",
      "metadata": {},
      "source": [
        "## property_type\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5a705bc8",
      "metadata": {},
      "outputs": [],
      "source": [
        "sns.countplot(data=df, x=\"property_type\")\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "3b18a935",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4), sharey=False)\n",
        "sns.boxplot(data=df, x=\"property_type\", y=target_col, ax=axes[0])\n",
        "axes[0].set_title(\"target_col by property_type\")\n",
        "\n",
        "sns.boxplot(data=df, x=\"property_type\", y=log_target_col, ax=axes[1])\n",
        "axes[1].set_title(\"log_target_col by property_type\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d9efd836",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.violinplot(data=df, x=\"property_type\", y=target_col, cut=0, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by property_type\")\n",
        "\n",
        "sns.violinplot(data=df, x=\"property_type\", y=log_target_col, cut=0, ax=axes[1])\n",
        "axes[1].set_title(f\"{log_target_col} by property_type\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "cc311fed",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.histplot(\n",
        "    data=df,\n",
        "    x=target_col,\n",
        "    hue=\"property_type\",\n",
        "    bins=50,\n",
        "    element=\"step\",\n",
        "    stat=\"density\",\n",
        "    common_norm=False,\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"{target_col} | hist by property_type\")\n",
        "\n",
        "sns.histplot(\n",
        "    data=df,\n",
        "    x=log_target_col,\n",
        "    hue=\"property_type\",\n",
        "    bins=50,\n",
        "    element=\"step\",\n",
        "    stat=\"density\",\n",
        "    common_norm=False,\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} | hist by property_type\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c3",
      "metadata": {},
      "source": [
        "## purpose\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "880a5d4d",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"purpose\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "62bf8592",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.drop(columns=[\"purpose\"], inplace=True)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c4",
      "metadata": {},
      "source": [
        "## area_total_m2\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "bbedf00b",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"area_total_m2\"].sort_values()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "41d45ada",
      "metadata": {},
      "outputs": [],
      "source": [
        "sns.histplot(data=df, x=\"area_total_m2\", bins=50)\n",
        "plt.title(\"Distribution of area_total_m2\")\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5c61f591",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.scatterplot(data=df, x=\"area_total_m2\", y=target_col, ax=axes[0], alpha=0.5)\n",
        "axes[0].set_title(f\"{target_col} vs area_total_m2\")\n",
        "\n",
        "sns.scatterplot(\n",
        "    data=df, x=\"area_total_m2\", y=log_target_col, ax=axes[1], alpha=0.5\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} vs area_total_m2\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "df431b9a",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.regplot(\n",
        "    data=df,\n",
        "    x=\"area_total_m2\",\n",
        "    y=target_col,\n",
        "    ax=axes[0],\n",
        "    scatter_kws={\"alpha\": 0.4},\n",
        ")\n",
        "axes[0].set_title(f\"Linear trend: {target_col} ~ area_total_m2\")\n",
        "\n",
        "sns.regplot(\n",
        "    data=df,\n",
        "    x=\"area_total_m2\",\n",
        "    y=log_target_col,\n",
        "    ax=axes[1],\n",
        "    scatter_kws={\"alpha\": 0.4},\n",
        ")\n",
        "axes[1].set_title(f\"Linear trend: {log_target_col} ~ area_total_m2\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "80c4297f",
      "metadata": {},
      "outputs": [],
      "source": [
        "corr_target = df[[\"area_total_m2\", target_col]].corr().iloc[0, 1]\n",
        "corr_log = df[[\"area_total_m2\", log_target_col]].corr().iloc[0, 1]\n",
        "print(\"corr(area_total_m2, target_col)   =\", corr_target)\n",
        "print(\"corr(area_total_m2, log_target_col) =\", corr_log)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "0882c08c",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"area_total_m2_bin\"] = pd.qcut(df[\"area_total_m2\"], q=10, duplicates=\"drop\")\n",
        "fig, axes = plt.subplots(1, 2, figsize=(14, 4))\n",
        "sns.boxplot(data=df, x=\"area_total_m2_bin\", y=target_col, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by area_total_m2 deciles\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=45)\n",
        "\n",
        "sns.boxplot(data=df, x=\"area_total_m2_bin\", y=log_target_col, ax=axes[1])\n",
        "axes[1].set_title(f\"{log_target_col} by area_total_m2 deciles\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=45)\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "df.drop(columns=\"area_total_m2_bin\", inplace=True)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5783981f",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"log1p_areat_total_m2\"] = df[\"area_total_m2\"].apply(np.log1p)\n",
        "df[\"sqrt_areat_total_m2\"] = df[\"area_total_m2\"].apply(np.sqrt)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8343c186",
      "metadata": {},
      "outputs": [],
      "source": [
        "sns.histplot(df[\"log1p_areat_total_m2\"])"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c5",
      "metadata": {},
      "source": [
        "## wall_material\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "e40bb79a",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"wall_material\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "99deeefc",
      "metadata": {},
      "outputs": [],
      "source": [
        "rules = [\n",
        "    (\"кирпич\", r\"кирпич\"),\n",
        "    (\"блок\", r\"блок\"),\n",
        "    (\"железобет\", r\"железобет|сборн.*железобет|ж/б\"),\n",
        "    (\"бетон\", r\"\\bбетон\\b|монолит\"),\n",
        "    (\"дерево\", r\"дерев|брус|бревн|доск\"),\n",
        "    (\"камень\", r\"кам(ень|ни)|природн\"),\n",
        "    (\"металл\", r\"металл\"),\n",
        "    (\"панель\", r\"панел\"),\n",
        "    (\"стекло\", r\"стекл\"),\n",
        "    (\"смешан\", r\"смешан|комбинир|каркас\"),\n",
        "    (\"прочее\", r\"друго|иное|не определ\"),\n",
        "]\n",
        "\n",
        "cats = pd.Series(df[\"wall_material\"].dropna().unique()).astype(str)\n",
        "\n",
        "\n",
        "def _key(s):\n",
        "    t = s.lower()\n",
        "    for i, (_, pat) in enumerate(rules):\n",
        "        if re.search(pat, t):\n",
        "            return (i, t)\n",
        "    return (len(rules), t)  # всё, что не совпало — в конец, по алфавиту\n",
        "\n",
        "\n",
        "order = sorted(cats, key=_key)\n",
        "order, len(order)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "22431809",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(20, 10))\n",
        "sns.boxplot(data=df, y=\"wall_material\", x=target_col, ax=axes[0], order=order)\n",
        "axes[0].set_title(f\"{target_col} by wall_material\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=30)\n",
        "\n",
        "sns.boxplot(\n",
        "    data=df, y=\"wall_material\", x=log_target_col, ax=axes[1], order=order\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} by wall_material\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=30)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "68c9134f",
      "metadata": {},
      "source": [
        "Лучше объединить общие категори в одну (кирпичи в кирпичи и тд)\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d2559acd",
      "metadata": {},
      "outputs": [],
      "source": [
        "EXACT_MAP = {\n",
        "    \"Кирпич\": \"Кирпич\",\n",
        "    \"Кирпич толщиной кладки до 45 см\": \"Кирпич\",\n",
        "    \"Кирпич толщиной кладки более 51 см\": \"Кирпич\",\n",
        "    \"Блоки стеновые\": \"Блоки\",\n",
        "    \"Блоки легкобетонные (силикатные, шлакобетонные, газосиликатные и др.)\": \"Блоки (легкие)\",\n",
        "    \"Блоки бетонные\": \"Блоки\",\n",
        "    \"Крупноблочные из керамзитовых блоков и др.\": \"Блоки (легкие)\",\n",
        "    \"Блоки, камни, кирпичи\": \"Блоки\",\n",
        "    \"Железобетонные изделия\": \"Железобетон\",\n",
        "    \"Железобетон монолитный\": \"Железобетон\",\n",
        "    \"Колонны, диафрагмы жесткости, сборный железобетон\": \"Железобетон\",\n",
        "    \"Каркас ж/б с кирпичным заполнением\": \"Железобетон\",\n",
        "    \"Бетон монолитный\": \"Бетон\",\n",
        "    \"Бетон\": \"Бетон\",\n",
        "    \"Легкий бетон (шлакобетон, аглопоритобетон, опилкобетон и др.)\": \"Бетон (легкий)\",\n",
        "    \"Крупнопанельные\": \"Панели\",\n",
        "    \"Сэндвич-панели\": \"Панели\",\n",
        "    \"Панельные гофрированные (металл с утеплителем)\": \"Панели\",\n",
        "    \"Металл\": \"Металл\",\n",
        "    \"Древесина\": \"Деревянные\",\n",
        "    \"Дерево, бруски, бревна\": \"Деревянные\",\n",
        "    \"Брус\": \"Деревянные\",\n",
        "    \"Бревно\": \"Деревянные\",\n",
        "    \"Доски\": \"Деревянные\",\n",
        "    \"Изделия из древесины\": \"Деревянные\",\n",
        "    \"Камень керамический (мягкие и твердые породы)\": \"Камень\",\n",
        "    \"Камень природный\": \"Камень\",\n",
        "    \"Стекло\": \"Стекло\",\n",
        "    \"Смешанной конструкции\": \"Смешанные/каркасные\",\n",
        "    \"Каркасно-засыпные\": \"Смешанные/каркасные\",\n",
        "    \"Материал стен не определен\": \"Не определено\",\n",
        "    \"Иное\": \"Другое/Иное\",\n",
        "    \"Другое\": \"Другое/Иное\",\n",
        "}\n",
        "\n",
        "\n",
        "def to_clean_category(x):\n",
        "    # сначала пробуем точную мапу, иначе — общая нормализация\n",
        "    return EXACT_MAP.get(str(x).strip())"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "bf6b62a5",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"wall_material\"] = df[\"wall_material\"].apply(to_clean_category)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "429979ea",
      "metadata": {},
      "outputs": [],
      "source": [
        "sns.countplot(data=df, y=\"wall_material\")\n",
        "plt.title(\"wall_material_new | class counts\")\n",
        "plt.xticks(rotation=30)\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "4a12b824",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(18, 7))\n",
        "sns.boxplot(data=df, x=\"wall_material\", y=target_col, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by wall_material\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=30)\n",
        "\n",
        "sns.boxplot(data=df, x=\"wall_material\", y=log_target_col, ax=axes[1])\n",
        "axes[1].set_title(f\"{log_target_col} by wall_material\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=30)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "eb60d4b0",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"wall_material\"].fillna(df[\"wall_material\"].mode()[0], inplace=True)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c6",
      "metadata": {},
      "source": [
        "## deal_date\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "992e2701",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = add_date_features(df, \"deal_date\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f3cf48f7",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"deal_date\"].describe()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "deb5219a",
      "metadata": {},
      "outputs": [],
      "source": [
        "ts = (\n",
        "    df.dropna(subset=[\"deal_date\"])\n",
        "    .assign(cnt=1)\n",
        "    .set_index(\"deal_date\")[\"cnt\"]\n",
        "    .resample(\"MS\")\n",
        "    .sum()\n",
        "    .reset_index()\n",
        "    .rename(columns={\"deal_date\": \"period\", \"cnt\": \"count\"})\n",
        ")\n",
        "\n",
        "plt.figure(figsize=(8, 3))\n",
        "sns.lineplot(data=ts, x=\"period\", y=\"count\", marker=\"o\")\n",
        "plt.title(\"Сделки по месяцам\")\n",
        "plt.xlabel(\"Месяц\")\n",
        "plt.ylabel(\"Количество\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d0415cd0",
      "metadata": {},
      "outputs": [],
      "source": [
        "plt.figure(figsize=(8, 3))\n",
        "sns.histplot(df[\"deal_date\"].dropna().dt.date, bins=100)\n",
        "plt.title(\"Распределение сделок по дням\")\n",
        "plt.xlabel(\"Дата\")\n",
        "plt.ylabel(\"Количество\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "71df36ea",
      "metadata": {},
      "outputs": [],
      "source": [
        "ts_mean = (\n",
        "    df.dropna(subset=[\"deal_date\"])\n",
        "    .set_index(\"deal_date\")\n",
        "    .resample(\"MS\")[[target_col, log_target_col]]\n",
        "    .mean()\n",
        "    .reset_index()\n",
        "    .rename(columns={\"deal_date\": \"period\"})\n",
        ")\n",
        "\n",
        "fig, axes = plt.subplots(1, 2, figsize=(14, 3.5), sharex=True)\n",
        "sns.lineplot(data=ts_mean, x=\"period\", y=target_col, marker=\"o\", ax=axes[0])\n",
        "axes[0].set_title(f\"Среднее {target_col} по месяцам\")\n",
        "sns.lineplot(data=ts_mean, x=\"period\", y=log_target_col, marker=\"o\", ax=axes[1])\n",
        "axes[1].set_title(f\"Среднее {log_target_col} по месяцам\")\n",
        "for ax in axes:\n",
        "    ax.set_xlabel(\"Месяц\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "0da86e78",
      "metadata": {},
      "source": [
        "Видно, что инфы до 2020 года, очень мало\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "6db08f25",
      "metadata": {},
      "outputs": [],
      "source": [
        "by_dow = df[\"dayofweek\"].value_counts().sort_index().reset_index()\n",
        "by_dow.columns = [\"dayofweek\", \"count\"]\n",
        "\n",
        "plt.figure(figsize=(6, 3))\n",
        "sns.barplot(data=by_dow, x=\"dayofweek\", y=\"count\")\n",
        "plt.title(\"Распределение по дням недели\")\n",
        "plt.xlabel(\"День недели (0=Пн … 6=Вс)\")\n",
        "plt.ylabel(\"Количество\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d67b7d05",
      "metadata": {},
      "outputs": [],
      "source": [
        "by_dow_val = df.dropna(subset=[\"dayofweek\"])[\n",
        "    [\"dayofweek\", target_col, log_target_col]\n",
        "].melt(id_vars=\"dayofweek\", var_name=\"which\", value_name=\"val\")\n",
        "\n",
        "fig, axes = plt.subplots(1, 2, figsize=(12, 3.5), sharey=False)\n",
        "sns.barplot(\n",
        "    data=by_dow_val.query(\"which == @target_col\"),\n",
        "    x=\"dayofweek\",\n",
        "    y=\"val\",\n",
        "    estimator=\"mean\",\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"Mean {target_col} по дням недели\")\n",
        "sns.barplot(\n",
        "    data=by_dow_val.query(\"which == @log_target_col\"),\n",
        "    x=\"dayofweek\",\n",
        "    y=\"val\",\n",
        "    estimator=\"mean\",\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"Mean {log_target_col} по дням недели\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "521535df",
      "metadata": {},
      "outputs": [],
      "source": [
        "by_month = df[\"month\"].value_counts().sort_index().reset_index()\n",
        "by_month.columns = [\"month\", \"count\"]\n",
        "\n",
        "plt.figure(figsize=(6, 3))\n",
        "sns.barplot(data=by_month, x=\"month\", y=\"count\")\n",
        "plt.title(\"Распределение по месяцам\")\n",
        "plt.xlabel(\"Месяц\")\n",
        "plt.ylabel(\"Количество\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "35a12c29",
      "metadata": {},
      "outputs": [],
      "source": [
        "by_month_val = df.dropna(subset=[\"month\"])[\n",
        "    [\"month\", target_col, log_target_col]\n",
        "].melt(id_vars=\"month\", var_name=\"which\", value_name=\"val\")\n",
        "\n",
        "fig, axes = plt.subplots(1, 2, figsize=(12, 3.5), sharex=True)\n",
        "sns.barplot(\n",
        "    data=by_month_val.query(\"which == @target_col\"),\n",
        "    x=\"month\",\n",
        "    y=\"val\",\n",
        "    estimator=\"mean\",\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"Mean {target_col} по месяцам\")\n",
        "sns.barplot(\n",
        "    data=by_month_val.query(\"which == @log_target_col\"),\n",
        "    x=\"month\",\n",
        "    y=\"val\",\n",
        "    estimator=\"mean\",\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"Mean {log_target_col} по месяцам\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "973cdf52",
      "metadata": {},
      "outputs": [],
      "source": [
        "by_q = df[\"quarter\"].value_counts().sort_index().reset_index()\n",
        "by_q.columns = [\"quarter\", \"count\"]\n",
        "\n",
        "plt.figure(figsize=(5, 3))\n",
        "sns.barplot(data=by_q, x=\"quarter\", y=\"count\")\n",
        "plt.title(\"Распределение по кварталам\")\n",
        "plt.xlabel(\"Квартал\")\n",
        "plt.ylabel(\"Количество\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "51d05582",
      "metadata": {},
      "outputs": [],
      "source": [
        "by_q_val = df.dropna(subset=[\"quarter\"])[\n",
        "    [\"quarter\", target_col, log_target_col]\n",
        "].melt(id_vars=\"quarter\", var_name=\"which\", value_name=\"val\")\n",
        "\n",
        "fig, axes = plt.subplots(1, 2, figsize=(10, 3.5))\n",
        "sns.barplot(\n",
        "    data=by_q_val.query(\"which == @target_col\"),\n",
        "    x=\"quarter\",\n",
        "    y=\"val\",\n",
        "    estimator=\"mean\",\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"Mean {target_col} по кварталам\")\n",
        "sns.barplot(\n",
        "    data=by_q_val.query(\"which == @log_target_col\"),\n",
        "    x=\"quarter\",\n",
        "    y=\"val\",\n",
        "    estimator=\"mean\",\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"Mean {log_target_col} по кварталам\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b070f28b",
      "metadata": {},
      "outputs": [],
      "source": [
        "pivot = (\n",
        "    df.pivot_table(\n",
        "        index=\"dayofweek\",\n",
        "        columns=\"month\",\n",
        "        values=\"deal_date\",\n",
        "        aggfunc=\"count\",\n",
        "    )\n",
        "    .fillna(0)\n",
        "    .reindex(index=[0, 1, 2, 3, 4, 5, 6], columns=range(1, 13))\n",
        ")\n",
        "\n",
        "plt.figure(figsize=(7, 3.6))\n",
        "ax = sns.heatmap(\n",
        "    pivot, annot=True, fmt=\".0f\", cbar=True, linewidths=0.5, linecolor=\"white\"\n",
        ")\n",
        "ax.set_title(\"Интенсивность: день недели × месяц\")\n",
        "ax.set_xlabel(\"Месяц\")\n",
        "ax.set_ylabel(\"День недели (0=Пн … 6=Вс)\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "84af861f",
      "metadata": {},
      "outputs": [],
      "source": [
        "pivot_t = df.pivot_table(\n",
        "    index=\"dayofweek\", columns=\"month\", values=target_col, aggfunc=\"mean\"\n",
        ").reindex(index=[0, 1, 2, 3, 4, 5, 6], columns=range(1, 13))\n",
        "pivot_l = df.pivot_table(\n",
        "    index=\"dayofweek\", columns=\"month\", values=log_target_col, aggfunc=\"mean\"\n",
        ").reindex(index=[0, 1, 2, 3, 4, 5, 6], columns=range(1, 13))\n",
        "\n",
        "fig, axes = plt.subplots(1, 2, figsize=(14, 4))\n",
        "sns.heatmap(\n",
        "    pivot_t,\n",
        "    annot=False,\n",
        "    cbar=True,\n",
        "    linewidths=0.4,\n",
        "    linecolor=\"white\",\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"Mean {target_col}: dow × month\")\n",
        "axes[0].set_xlabel(\"Месяц\")\n",
        "axes[0].set_ylabel(\"День недели\")\n",
        "sns.heatmap(\n",
        "    pivot_l,\n",
        "    annot=False,\n",
        "    cbar=True,\n",
        "    linewidths=0.4,\n",
        "    linecolor=\"white\",\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"Mean {log_target_col}: dow × month\")\n",
        "axes[1].set_xlabel(\"Месяц\")\n",
        "axes[1].set_ylabel(\"День недели\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "96b0b99f",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(14, 3.5), sharex=True)\n",
        "sns.regplot(\n",
        "    data=df,\n",
        "    x=\"days_since_min\",\n",
        "    y=target_col,\n",
        "    scatter_kws={\"alpha\": 0.3, \"s\": 15},\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"{target_col} ~ days_since_min\")\n",
        "axes[0].set_xlabel(\"Дней с минимальной даты\")\n",
        "sns.regplot(\n",
        "    data=df,\n",
        "    x=\"days_since_min\",\n",
        "    y=log_target_col,\n",
        "    scatter_kws={\"alpha\": 0.3, \"s\": 15},\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} ~ days_since_min\")\n",
        "axes[1].set_xlabel(\"Дней с минимальной даты\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c7",
      "metadata": {},
      "source": [
        "## contract_reg_date\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "65a50f64",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"contract_reg_date\"].isna().sum()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "e1119f3a",
      "metadata": {},
      "outputs": [],
      "source": [
        "ts = (\n",
        "    df.dropna(subset=[\"contract_reg_date\"])\n",
        "    .assign(cnt=1)\n",
        "    .set_index(\"contract_reg_date\")[\"cnt\"]\n",
        "    .resample(\"MS\")\n",
        "    .sum()\n",
        "    .reset_index()\n",
        "    .rename(columns={\"contract_reg_date\": \"period\", \"cnt\": \"count\"})\n",
        ")\n",
        "\n",
        "plt.figure(figsize=(8, 3))\n",
        "sns.lineplot(data=ts, x=\"period\", y=\"count\", marker=\"o\")\n",
        "plt.title(\"contract_reg_date по месяцам\")\n",
        "plt.xlabel(\"Месяц\")\n",
        "plt.ylabel(\"Количество\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "4ec34f85",
      "metadata": {},
      "outputs": [],
      "source": [
        "plt.figure(figsize=(8, 3))\n",
        "sns.histplot(df[\"contract_reg_date\"].dropna().dt.date, bins=30)\n",
        "plt.title(\"Распределение contract_reg_date по дням\")\n",
        "plt.xlabel(\"Дата\")\n",
        "plt.ylabel(\"Количество\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d00697b9",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = df.drop(columns=[\"contract_reg_date\"])"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c8",
      "metadata": {},
      "source": [
        "## deal_objects_count\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "49d060bc",
      "metadata": {},
      "outputs": [],
      "source": [
        "vc = (\n",
        "    df[\"deal_objects_count\"]\n",
        "    .value_counts(dropna=True)\n",
        "    .sort_values(ascending=False)\n",
        "    .reset_index()\n",
        ")\n",
        "vc.columns = [\"deal_objects_count\", \"count\"]\n",
        "\n",
        "plt.figure(figsize=(10, 4))\n",
        "sns.barplot(data=vc.head(30), x=\"deal_objects_count\", y=\"count\")\n",
        "plt.title(\"Топ-30 значений deal_objects_count по частоте\")\n",
        "plt.xticks(rotation=45)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "df539a83",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(14, 4))\n",
        "sns.regplot(\n",
        "    data=df,\n",
        "    x=\"deal_objects_count\",\n",
        "    y=target_col,\n",
        "    scatter_kws={\"alpha\": 0.35, \"s\": 15},\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"{target_col} ~ deal_objects_count\")\n",
        "\n",
        "sns.regplot(\n",
        "    data=df,\n",
        "    x=\"deal_objects_count\",\n",
        "    y=log_target_col,\n",
        "    scatter_kws={\"alpha\": 0.35, \"s\": 15},\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} ~ deal_objects_count\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8056caf9",
      "metadata": {},
      "outputs": [],
      "source": [
        "top_vals = vc.head(15)[\"deal_objects_count\"].tolist()\n",
        "\n",
        "fig, axes = plt.subplots(1, 2, figsize=(14, 4), sharex=True)\n",
        "sns.barplot(\n",
        "    data=df[df[\"deal_objects_count\"].isin(top_vals)],\n",
        "    x=\"deal_objects_count\",\n",
        "    y=target_col,\n",
        "    estimator=\"mean\",\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"Mean {target_col} для топ-15 deal_objects_count\")\n",
        "sns.barplot(\n",
        "    data=df[df[\"deal_objects_count\"].isin(top_vals)],\n",
        "    x=\"deal_objects_count\",\n",
        "    y=log_target_col,\n",
        "    estimator=\"mean\",\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"Mean {log_target_col} для топ-15 deal_objects_count\")\n",
        "for ax in axes:\n",
        "    ax.set_xlabel(\"deal_objects_count\")\n",
        "    ax.tick_params(axis=\"x\", rotation=45)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c10",
      "metadata": {},
      "source": [
        "## transferred_share\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "da95141b",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"transferred_share\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "37c2a7ba",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"transferred_share\"].fillna(\"NaN\", inplace=True)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "9d6fbf4f",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(18, 7))\n",
        "sns.boxplot(data=df, x=\"transferred_share\", y=target_col, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by transferred_share\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=30)\n",
        "\n",
        "sns.boxplot(data=df, x=\"transferred_share\", y=log_target_col, ax=axes[1])\n",
        "axes[1].set_title(f\"{log_target_col} by transferred_share\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=30)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c11",
      "metadata": {},
      "source": [
        "## unit_floor\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f4d13fae",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"unit_floor\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f192dab6",
      "metadata": {},
      "outputs": [],
      "source": [
        "# уже есть переменная floor\n",
        "df.drop(columns=[\"unit_floor\"], inplace=True)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c12",
      "metadata": {},
      "source": [
        "## ks_area_total_m2\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "2c8d0dfd",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[[\"area_total_m2\", \"ks_area_total_m2\"]]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "6c28b56f",
      "metadata": {},
      "outputs": [],
      "source": [
        "sns.histplot(data=df, x=\"ks_area_total_m2\", bins=60)\n",
        "plt.title(\"Distribution of ks_area_total_m2\")\n",
        "plt.xlabel(\"ks_area_total_m2\")\n",
        "plt.ylabel(\"count\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "cf895546",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.scatterplot(\n",
        "    data=df, x=\"ks_area_total_m2\", y=target_col, alpha=0.5, ax=axes[0]\n",
        ")\n",
        "axes[0].set_title(f\"{target_col} vs ks_area_total_m2\")\n",
        "\n",
        "sns.scatterplot(\n",
        "    data=df, x=\"ks_area_total_m2\", y=log_target_col, alpha=0.5, ax=axes[1]\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} vs ks_area_total_m2\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "19865a84",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.regplot(\n",
        "    data=df,\n",
        "    x=\"ks_area_total_m2\",\n",
        "    y=target_col,\n",
        "    scatter_kws={\"alpha\": 0.35, \"s\": 15},\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"Linear trend: {target_col} ~ ks_area_total_m2\")\n",
        "\n",
        "sns.regplot(\n",
        "    data=df,\n",
        "    x=\"ks_area_total_m2\",\n",
        "    y=log_target_col,\n",
        "    scatter_kws={\"alpha\": 0.35, \"s\": 15},\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"Linear trend: {log_target_col} ~ ks_area_total_m2\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "9d2e9305",
      "metadata": {},
      "outputs": [],
      "source": [
        "corr_area = df[[\"ks_area_total_m2\", \"area_total_m2\"]].corr().iloc[0, 1]\n",
        "print(\"Correlation between ares features\", corr_area)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "be040023",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"_ks_area_bin\"] = pd.qcut(df[\"ks_area_total_m2\"], q=10, duplicates=\"drop\")\n",
        "\n",
        "fig, axes = plt.subplots(1, 2, figsize=(14, 4))\n",
        "sns.boxplot(data=df, x=\"_ks_area_bin\", y=target_col, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by ks_area_total_m2 deciles\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=45)\n",
        "\n",
        "sns.boxplot(data=df, x=\"_ks_area_bin\", y=log_target_col, ax=axes[1])\n",
        "axes[1].set_title(f\"{log_target_col} by ks_area_total_m2 deciles\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=45)\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "\n",
        "df.drop(columns=\"_ks_area_bin\", inplace=True)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "948f35a1",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.scatterplot(\n",
        "    data=df, x=\"ks_area_total_m2\", y=target_col, alpha=0.4, ax=axes[0]\n",
        ")\n",
        "axes[0].set_xscale(\"log\")\n",
        "axes[0].set_title(f\"{target_col} vs ks_area_total_m2 (log X)\")\n",
        "\n",
        "sns.scatterplot(\n",
        "    data=df, x=\"ks_area_total_m2\", y=log_target_col, alpha=0.4, ax=axes[1]\n",
        ")\n",
        "axes[1].set_xscale(\"log\")\n",
        "axes[1].set_title(f\"{log_target_col} vs ks_area_total_m2 (log X)\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8a257321",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(df[\"ks_area_total_m2\"].median())\n",
        "df[\"ks_area_total_m2\"].fillna(df[\"ks_area_total_m2\"].median(), inplace=True)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5c9efee9",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"log1p_ks_area_total_m2\"] = df[\"ks_area_total_m2\"].apply(np.log1p)\n",
        "df[\"sqrt_ks_area_total_m2\"] = df[\"ks_area_total_m2\"].apply(np.sqrt)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c13",
      "metadata": {},
      "source": [
        "## ks_completion_pct\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "7775451d",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"ks_completion_pct\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c8543b6a",
      "metadata": {},
      "source": [
        "Заменим фичу на булево\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "48c16d04",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"ks_completion_bool\"] = df[\"ks_completion_pct\"].apply(\n",
        "    lambda x: 1 if x == 100 else 0\n",
        ")\n",
        "df[\"ks_completion_bool\"].value_counts()\n",
        "df = df.drop(columns=[\"ks_completion_pct\"])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "2523317d",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(10, 4))\n",
        "sns.boxplot(\n",
        "    data=df, x=\"ks_completion_bool\", y=target_col, order=[0, 1], ax=axes[0]\n",
        ")\n",
        "axes[0].set_title(f\"{target_col} by ks_completion_bool\")\n",
        "\n",
        "sns.boxplot(\n",
        "    data=df, x=\"ks_completion_bool\", y=log_target_col, order=[0, 1], ax=axes[1]\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} by ks_completion_bool\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "fa3292cc",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(10, 4))\n",
        "sns.violinplot(\n",
        "    data=df,\n",
        "    x=\"ks_completion_bool\",\n",
        "    y=target_col,\n",
        "    cut=0,\n",
        "    order=[0, 1],\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"{target_col} by ks_completion_bool\")\n",
        "\n",
        "sns.violinplot(\n",
        "    data=df,\n",
        "    x=\"ks_completion_bool\",\n",
        "    y=log_target_col,\n",
        "    cut=0,\n",
        "    order=[0, 1],\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} by ks_completion_bool\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8ac65138",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.histplot(\n",
        "    data=df,\n",
        "    x=target_col,\n",
        "    hue=\"ks_completion_bool\",\n",
        "    bins=50,\n",
        "    element=\"step\",\n",
        "    stat=\"density\",\n",
        "    common_norm=False,\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"{target_col}: hist by ks_completion_bool\")\n",
        "\n",
        "sns.histplot(\n",
        "    data=df,\n",
        "    x=log_target_col,\n",
        "    hue=\"ks_completion_bool\",\n",
        "    bins=50,\n",
        "    element=\"step\",\n",
        "    stat=\"density\",\n",
        "    common_norm=False,\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col}: hist by ks_completion_bool\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c14",
      "metadata": {},
      "source": [
        "## floors_above\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "1f095650",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"floors_above\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "eaad33cd",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(18, 7))\n",
        "sns.boxplot(data=df, x=\"floors_above\", y=target_col, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by floors_above\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=30)\n",
        "\n",
        "sns.boxplot(data=df, x=\"floors_above\", y=log_target_col, ax=axes[1])\n",
        "axes[1].set_title(f\"{log_target_col} by floors_above\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=30)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c15",
      "metadata": {},
      "source": [
        "## floors_below\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f92895c8",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"floors_below\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "2e3fedac",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(18, 7))\n",
        "sns.boxplot(data=df, x=\"floors_below\", y=target_col, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by floors_below\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=30)\n",
        "\n",
        "sns.boxplot(data=df, x=\"floors_below\", y=log_target_col, ax=axes[1])\n",
        "axes[1].set_title(f\"{log_target_col} by floors_below\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=30)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c16",
      "metadata": {},
      "source": [
        "## land_use\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "255e6fd3",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"land_use\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "4d80bc7f",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = df.drop(columns=[\"land_use\"])"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c17",
      "metadata": {},
      "source": [
        "## land_area_m2\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "464ae9ab",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(df[\"land_area_m2\"].isna().sum())"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "36e35ee6",
      "metadata": {},
      "outputs": [],
      "source": [
        "sns.histplot(data=df, x=\"land_area_m2\", bins=60)\n",
        "plt.title(\"Distribution of land_area_m2\")\n",
        "plt.xlabel(\"land_area_m2\")\n",
        "plt.ylabel(\"count\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "29d634e9",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.scatterplot(data=df, x=\"land_area_m2\", y=target_col, alpha=0.5, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} vs land_area_m2\")\n",
        "\n",
        "sns.scatterplot(\n",
        "    data=df, x=\"land_area_m2\", y=log_target_col, alpha=0.5, ax=axes[1]\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} vs land_area_m2\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "aad2e821",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.regplot(\n",
        "    data=df,\n",
        "    x=\"land_area_m2\",\n",
        "    y=target_col,\n",
        "    scatter_kws={\"alpha\": 0.35, \"s\": 15},\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"Linear trend: {target_col} ~ land_area_m2\")\n",
        "\n",
        "sns.regplot(\n",
        "    data=df,\n",
        "    x=\"land_area_m2\",\n",
        "    y=log_target_col,\n",
        "    scatter_kws={\"alpha\": 0.35, \"s\": 15},\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"Linear trend: {log_target_col} ~ land_area_m2\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "caa49110",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.scatterplot(data=df, x=\"land_area_m2\", y=target_col, alpha=0.4, ax=axes[0])\n",
        "axes[0].set_xscale(\"log\")\n",
        "axes[0].set_title(f\"{target_col} vs land_area_m2 (log X)\")\n",
        "\n",
        "sns.scatterplot(\n",
        "    data=df, x=\"land_area_m2\", y=log_target_col, alpha=0.4, ax=axes[1]\n",
        ")\n",
        "axes[1].set_xscale(\"log\")\n",
        "axes[1].set_title(f\"{log_target_col} vs land_area_m2 (log X)\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "80fa0338",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(df[\"land_area_m2\"].median())\n",
        "df[\"land_area_m2\"].fillna(df[\"land_area_m2\"].median(), inplace=True)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "0325223e",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"log1p_land_area_m2\"] = df[\"land_area_m2\"].apply(np.log1p)\n",
        "df[\"sqrt_land_area_m2\"] = df[\"land_area_m2\"].apply(np.sqrt)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c18",
      "metadata": {},
      "source": [
        "## markers\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "950e1c7e",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"markers\"].value_counts()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8e12ce12",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = df.drop(columns=[\"markers\"])"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c19",
      "metadata": {},
      "source": [
        "## shares_before\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "4c185480",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"shares_before\"].value_counts()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "0a4f804b",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = df.drop(columns=[\"shares_before\"])"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c20",
      "metadata": {},
      "source": [
        "## shares_after\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "82634219",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"shares_after\"].value_counts()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "e0b7fd7a",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = df.drop(columns=[\"shares_after\"])"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c21",
      "metadata": {
        "notebookRunGroups": {
          "groupValue": "1"
        }
      },
      "source": [
        "## eur_rate\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "e95f5e33",
      "metadata": {
        "notebookRunGroups": {
          "groupValue": "2"
        }
      },
      "outputs": [],
      "source": [
        "print(df[\"eur_rate\"].isna().sum())\n",
        "print(df[\"usd_rate\"].isna().sum())\n",
        "print(df[\"rub_rate\"].isna().sum())"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "954f510d",
      "metadata": {},
      "outputs": [],
      "source": [
        "date_key = df[\"deal_date\"].dt.normalize()\n",
        "\n",
        "daily_known = (\n",
        "    df.loc[df[\"eur_rate\"].notna()]\n",
        "    .groupby(date_key[df[\"eur_rate\"].notna()])[\"eur_rate\"]\n",
        "    .first()\n",
        ")\n",
        "df[\"eur_rate\"] = df[\"eur_rate\"].fillna(date_key.map(daily_known))\n",
        "\n",
        "daily_known = (\n",
        "    df.loc[df[\"usd_rate\"].notna()]\n",
        "    .groupby(date_key[df[\"usd_rate\"].notna()])[\"usd_rate\"]\n",
        "    .first()\n",
        ")\n",
        "df[\"usd_rate\"] = df[\"usd_rate\"].fillna(date_key.map(daily_known))\n",
        "\n",
        "daily_known = (\n",
        "    df.loc[df[\"rub_rate\"].notna()]\n",
        "    .groupby(date_key[df[\"rub_rate\"].notna()])[\"rub_rate\"]\n",
        "    .first()\n",
        ")\n",
        "df[\"rub_rate\"] = df[\"rub_rate\"].fillna(date_key.map(daily_known))"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "dacd171c",
      "metadata": {},
      "source": [
        "Есть пропуски ~40 для всех курсов, интерполируем значения с помощью `deal_date`\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "e8275ca1",
      "metadata": {},
      "outputs": [],
      "source": [
        "ts_eur = (\n",
        "    df.dropna(subset=[\"deal_date\", \"eur_rate\"])\n",
        "    .set_index(\"deal_date\")[\"eur_rate\"]\n",
        "    .resample(\"MS\")\n",
        "    .mean()\n",
        "    .reset_index()\n",
        ")\n",
        "\n",
        "plt.figure(figsize=(10, 3.5))\n",
        "sns.lineplot(data=ts_eur, x=\"deal_date\", y=\"eur_rate\", marker=\"o\")\n",
        "plt.title(\"eur_rate по месяцам\")\n",
        "plt.xlabel(\"Месяц\")\n",
        "plt.ylabel(\"eur_rate\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c22",
      "metadata": {},
      "source": [
        "## rub_rate\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "6321dc1f",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = df[df[\"rub_rate\"].notna()]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "21564923",
      "metadata": {},
      "outputs": [],
      "source": [
        "ts_eur = (\n",
        "    df.dropna(subset=[\"deal_date\", \"rub_rate\"])\n",
        "    .set_index(\"deal_date\")[\"rub_rate\"]\n",
        "    .resample(\"MS\")\n",
        "    .mean()\n",
        "    .reset_index()\n",
        ")\n",
        "\n",
        "plt.figure(figsize=(10, 3.5))\n",
        "sns.lineplot(data=ts_eur, x=\"deal_date\", y=\"rub_rate\", marker=\"o\")\n",
        "plt.title(\"rub_rate по месяцам\")\n",
        "plt.xlabel(\"Месяц\")\n",
        "plt.ylabel(\"rub_rate\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c23",
      "metadata": {},
      "source": [
        "## usd_rate\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b1c92fef",
      "metadata": {},
      "outputs": [],
      "source": [
        "ts_eur = (\n",
        "    df.dropna(subset=[\"deal_date\", \"usd_rate\"])\n",
        "    .set_index(\"deal_date\")[\"usd_rate\"]\n",
        "    .resample(\"MS\")\n",
        "    .mean()\n",
        "    .reset_index()\n",
        ")\n",
        "\n",
        "plt.figure(figsize=(10, 3.5))\n",
        "sns.lineplot(data=ts_eur, x=\"deal_date\", y=\"usd_rate\", marker=\"o\")\n",
        "plt.title(\"usd_rate по месяцам\")\n",
        "plt.xlabel(\"Месяц\")\n",
        "plt.ylabel(\"usd_rate\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c24",
      "metadata": {},
      "source": [
        "## floor\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8ee084a6",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"floor\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c51c4f0d",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(18, 7))\n",
        "sns.boxplot(data=df, x=\"floor\", y=target_col, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by floor\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=30)\n",
        "\n",
        "sns.boxplot(data=df, x=\"floor\", y=log_target_col, ax=axes[1])\n",
        "axes[1].set_title(f\"{log_target_col} by floor\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=30)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c25",
      "metadata": {},
      "source": [
        "## category\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "9a2004d5",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"category\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "795feb47",
      "metadata": {},
      "outputs": [],
      "source": [
        "order_freq = df[\"category\"].value_counts().index.tolist()\n",
        "\n",
        "plt.figure(figsize=(10, 4))\n",
        "sns.countplot(data=df, x=\"category\", order=order_freq)\n",
        "plt.title(\"category | class counts\")\n",
        "plt.xticks(rotation=45, ha=\"right\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "a5650c82",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(14, 5))\n",
        "sns.boxplot(data=df, x=\"category\", y=target_col, order=order_freq, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by category\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=45)\n",
        "\n",
        "sns.boxplot(\n",
        "    data=df, x=\"category\", y=log_target_col, order=order_freq, ax=axes[1]\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} by category\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=45)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "24cb463a",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(14, 5))\n",
        "sns.violinplot(\n",
        "    data=df, x=\"category\", y=target_col, cut=0, order=order_freq, ax=axes[0]\n",
        ")\n",
        "axes[0].set_title(f\"{target_col} by category\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=45)\n",
        "\n",
        "sns.violinplot(\n",
        "    data=df, x=\"category\", y=log_target_col, cut=0, order=order_freq, ax=axes[1]\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} by category\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=45)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "4e345814",
      "metadata": {},
      "outputs": [],
      "source": [
        "sns.displot(\n",
        "    data=df,\n",
        "    x=log_target_col,\n",
        "    hue=\"category\",\n",
        "    kind=\"hist\",\n",
        "    bins=50,\n",
        "    element=\"step\",\n",
        "    stat=\"density\",\n",
        ")\n",
        "plt.suptitle(f\"Hist {log_target_col} by category\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "7a3b6402",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"category\"].fillna(\"undef\", inplace=True)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c26",
      "metadata": {},
      "source": [
        "## for_clusters_gr\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "0613eec6",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"for_clusters_gr\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "6cca7bb2",
      "metadata": {},
      "outputs": [],
      "source": [
        "order = df[\"for_clusters_gr\"].value_counts().index.tolist()\n",
        "\n",
        "# распределение классов\n",
        "plt.figure(figsize=(6, 3))\n",
        "sns.countplot(data=df, x=\"for_clusters_gr\", order=order)\n",
        "plt.title(\"for_clusters_gr | class counts\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "7971de98",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.boxplot(data=df, x=\"for_clusters_gr\", y=target_col, order=order, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by for_clusters_gr\")\n",
        "\n",
        "sns.boxplot(\n",
        "    data=df, x=\"for_clusters_gr\", y=log_target_col, order=order, ax=axes[1]\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} by for_clusters_gr\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "7e6f852c",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.violinplot(\n",
        "    data=df, x=\"for_clusters_gr\", y=target_col, cut=0, order=order, ax=axes[0]\n",
        ")\n",
        "axes[0].set_title(f\"{target_col} by for_clusters_gr\")\n",
        "\n",
        "sns.violinplot(\n",
        "    data=df,\n",
        "    x=\"for_clusters_gr\",\n",
        "    y=log_target_col,\n",
        "    cut=0,\n",
        "    order=order,\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} by for_clusters_gr\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "cd093ffb",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.histplot(\n",
        "    data=df,\n",
        "    x=target_col,\n",
        "    hue=\"for_clusters_gr\",\n",
        "    bins=50,\n",
        "    element=\"step\",\n",
        "    stat=\"density\",\n",
        "    common_norm=False,\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"{target_col}: hist by for_clusters_gr\")\n",
        "\n",
        "sns.histplot(\n",
        "    data=df,\n",
        "    x=log_target_col,\n",
        "    hue=\"for_clusters_gr\",\n",
        "    bins=50,\n",
        "    element=\"step\",\n",
        "    stat=\"density\",\n",
        "    common_norm=False,\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col}: hist by for_clusters_gr\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c27",
      "metadata": {},
      "source": [
        "## Name NP\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "0899f78f",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(df[\"Name NP\"].isna().sum())\n",
        "df[\"Name NP\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c28",
      "metadata": {},
      "source": [
        "## region_name\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8dc917a2",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(df[\"region_name\"].isna().sum())\n",
        "df[\"region_name\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c29",
      "metadata": {},
      "source": [
        "## oblast_name\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "1337105b",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"oblast_name\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "60d10d6c",
      "metadata": {},
      "outputs": [],
      "source": [
        "plt.figure(figsize=(7, 3))\n",
        "sns.countplot(data=df, x=\"oblast_name\")\n",
        "plt.title(\"oblast_name | counts\")\n",
        "plt.xticks(rotation=30)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d7bf3a93",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.boxplot(data=df, x=\"oblast_name\", y=target_col, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by oblast_name\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=30)\n",
        "\n",
        "sns.boxplot(data=df, x=\"oblast_name\", y=log_target_col, ax=axes[1])\n",
        "axes[1].set_title(f\"{log_target_col} by oblast_name\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=30)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "14471661",
      "metadata": {},
      "outputs": [],
      "source": [
        "g1 = sns.displot(\n",
        "    data=df,\n",
        "    x=target_col,\n",
        "    col=\"oblast_name\",\n",
        "    col_wrap=4,\n",
        "    bins=40,\n",
        "    element=\"step\",\n",
        "    stat=\"density\",\n",
        ")\n",
        "g1.fig.subplots_adjust(top=0.9)\n",
        "g1.fig.suptitle(f\"Hist {target_col} by oblast_name\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "9ab4b9d2",
      "metadata": {},
      "outputs": [],
      "source": [
        "g2 = sns.displot(\n",
        "    data=df,\n",
        "    x=log_target_col,\n",
        "    col=\"oblast_name\",\n",
        "    col_wrap=4,\n",
        "    bins=40,\n",
        "    element=\"step\",\n",
        "    stat=\"density\",\n",
        ")\n",
        "g2.fig.subplots_adjust(top=0.9)\n",
        "g2.fig.suptitle(f\"Hist {log_target_col} by oblast_name\")"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c30",
      "metadata": {},
      "source": [
        "## cluster_score\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "69ee253d",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"_cs_is_neg\"] = (df[\"cluster_score\"] == -1).astype(\"int8\")\n",
        "df[\"_cs_pos\"] = df[\"cluster_score\"].where(\n",
        "    df[\"cluster_score\"] >= 0\n",
        ")  # только валидные (>=0)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "110a05f1",
      "metadata": {},
      "outputs": [],
      "source": [
        "plt.figure(figsize=(6, 3))\n",
        "sns.countplot(x=df[\"_cs_is_neg\"].map({0: \">=0\", 1: \"-1 (neg)\"}))\n",
        "plt.title(\"cluster_score: доля -1 vs >=0\")\n",
        "plt.xlabel(\"\")\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "\n",
        "plt.figure(figsize=(8, 3))\n",
        "sns.histplot(df[\"_cs_pos\"].dropna(), bins=60)\n",
        "plt.title(\"cluster_score (>=0), full scale\")\n",
        "plt.xlabel(\"cluster_score\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "67015a6a",
      "metadata": {},
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "4c7ccad3",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(10, 4))\n",
        "sns.boxplot(data=df, x=\"_cs_is_neg\", y=target_col, ax=axes[0])\n",
        "axes[0].set_xticklabels([\">=0\", \"-1 (neg)\"])\n",
        "axes[0].set_title(f\"{target_col} by cluster_score group\")\n",
        "\n",
        "sns.boxplot(data=df, x=\"_cs_is_neg\", y=log_target_col, ax=axes[1])\n",
        "axes[1].set_xticklabels([\">=0\", \"-1 (neg)\"])\n",
        "axes[1].set_title(f\"{log_target_col} by cluster_score group\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "6ed44faa",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.drop(columns=[\"_cs_pos\"], inplace=True)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c31",
      "metadata": {},
      "source": [
        "## cluster\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "3b00324e",
      "metadata": {},
      "outputs": [],
      "source": [
        "plt.figure(figsize=(8, 3))\n",
        "sns.countplot(data=df, x=\"cluster\")\n",
        "plt.title(\"cluster | counts\")\n",
        "plt.xticks(rotation=30)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c678d98c",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(14, 4))\n",
        "sns.boxplot(data=df, x=\"cluster\", y=target_col, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by cluster\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=30)\n",
        "\n",
        "sns.boxplot(data=df, x=\"cluster\", y=log_target_col, ax=axes[1])\n",
        "axes[1].set_title(f\"{log_target_col} by cluster\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=30)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "593d0a27",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(14, 4))\n",
        "sns.violinplot(data=df, x=\"cluster\", y=target_col, cut=0, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by cluster\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=30)\n",
        "\n",
        "sns.violinplot(data=df, x=\"cluster\", y=log_target_col, cut=0, ax=axes[1])\n",
        "axes[1].set_title(f\"{log_target_col} by cluster\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=30)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d54cb8e3",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(14, 4))\n",
        "sns.histplot(\n",
        "    data=df,\n",
        "    x=target_col,\n",
        "    hue=\"cluster\",\n",
        "    bins=50,\n",
        "    element=\"step\",\n",
        "    stat=\"density\",\n",
        "    common_norm=False,\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"{target_col}: hist by cluster\")\n",
        "\n",
        "sns.histplot(\n",
        "    data=df,\n",
        "    x=log_target_col,\n",
        "    hue=\"cluster\",\n",
        "    bins=50,\n",
        "    element=\"step\",\n",
        "    stat=\"density\",\n",
        "    common_norm=False,\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col}: hist by cluster\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8bec3002",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.to_csv(\"./data/after_eda.csv\", index=False)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "dc9629bd",
      "metadata": {},
      "source": [
        "# Model\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "87996470",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = pd.read_csv(\"./data/after_eda.csv\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f7b5a629",
      "metadata": {},
      "outputs": [],
      "source": [
        "from lightgbm import LGBMRegressor\n",
        "from sklearn.model_selection import train_test_split\n",
        "from sklearn.metrics import (\n",
        "    mean_squared_error,\n",
        "    mean_absolute_error,\n",
        "    root_mean_squared_error,\n",
        "    mean_absolute_percentage_error,\n",
        ")\n",
        "\n",
        "\n",
        "# ====== Метрики ======\n",
        "def smape_metric(y_true, y_pred, eps=1e-9):\n",
        "    y_true = np.asarray(y_true)\n",
        "    y_pred = np.asarray(y_pred)\n",
        "    denom = np.abs(y_true) + np.abs(y_pred) + eps\n",
        "    return 100.0 * np.mean(2.0 * np.abs(y_pred - y_true) / denom)\n",
        "\n",
        "\n",
        "def mdape_metric(y_true, y_pred, eps=1e-8):\n",
        "    y_true = np.asarray(y_true)\n",
        "    y_pred = np.asarray(y_pred)\n",
        "    denom = np.where(np.abs(y_true) < eps, eps, np.abs(y_true))\n",
        "    ape = np.abs(y_true - y_pred) / denom\n",
        "    return np.median(ape) * 100.0\n",
        "\n",
        "\n",
        "def compute_metrics(y_true_orig, y_pred_orig):\n",
        "    rmse = root_mean_squared_error(y_true_orig, y_pred_orig)\n",
        "    mae = mean_absolute_error(y_true_orig, y_pred_orig)\n",
        "    mse = mean_squared_error(y_true_orig, y_pred_orig)\n",
        "    mape = 100.0 * mean_absolute_percentage_error(y_true_orig, y_pred_orig)\n",
        "    mdape = mdape_metric(y_true_orig, y_pred_orig)\n",
        "    smape = smape_metric(y_true_orig, y_pred_orig)\n",
        "    return {\n",
        "        \"rmse\": rmse,\n",
        "        \"mse\": mse,\n",
        "        \"mae\": mae,\n",
        "        \"mape_%\": mape,\n",
        "        \"median_mape_%\": mdape,\n",
        "        \"smape_%\": smape,\n",
        "    }"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "91024e34",
      "metadata": {},
      "outputs": [],
      "source": [
        "SHUFFLE = True\n",
        "TEST_SIZE = 0.25\n",
        "RANDOM_STATE = 42"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "655f9ac8",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.sort_values(\"deal_date\", inplace=True)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "53c63d05",
      "metadata": {},
      "outputs": [],
      "source": [
        "TARGET = \"price_usd_per_m2\"\n",
        "TARGET_LOG = \"log1p_price_usd_per_m2\""
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "4a2dedcb",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.drop(columns=[\"inventory_id\", \"deal_date\"], inplace=True)\n",
        "\n",
        "Y = df[TARGET]\n",
        "X = df.drop(columns=[TARGET, TARGET_LOG])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "13bb92c7",
      "metadata": {},
      "outputs": [],
      "source": [
        "cat_cols = [\n",
        "    \"property_type\",\n",
        "    \"wall_material\",\n",
        "    \"transferred_share\",\n",
        "    \"category\",\n",
        "    \"for_clusters_gr\",\n",
        "    \"Name NP\",\n",
        "    \"region_name\",\n",
        "    \"oblast_name\",\n",
        "    \"cluster\",\n",
        "]\n",
        "cat_idx = [X.columns.get_loc(c) for c in cat_cols]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "bdb2bd71",
      "metadata": {},
      "outputs": [],
      "source": [
        "X_train, X_valid, y_train, y_valid = train_test_split(\n",
        "    X,\n",
        "    Y,\n",
        "    test_size=TEST_SIZE,\n",
        "    random_state=RANDOM_STATE,\n",
        "    shuffle=SHUFFLE,\n",
        "    # stratify=X[\"bin_drop\"],\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "0aae22de",
      "metadata": {},
      "outputs": [],
      "source": [
        "sns.histplot(y_train)\n",
        "sns.histplot(y_valid)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "359334b3",
      "metadata": {},
      "outputs": [],
      "source": [
        "X_train[cat_cols] = X_train[cat_cols].astype(\"category\")\n",
        "X_valid[cat_cols] = X_valid[cat_cols].astype(\"category\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f08c4955",
      "metadata": {},
      "outputs": [],
      "source": [
        "best_params = {\n",
        "    \"boosting_type\": \"gbdt\",\n",
        "    \"colsample_bytree\": 0.7,  # Увеличение рандомизации признаков\n",
        "    \"importance_type\": \"split\",\n",
        "    \"learning_rate\": 0.01,  # Уменьшение темпа обучения\n",
        "    \"max_depth\": 5,  # Уменьшение глубины\n",
        "    \"min_child_samples\": 11,\n",
        "    \"min_child_weight\": 8.0,  # Увеличение веса листа\n",
        "    \"min_data_in_leaf\": 15,  # Увеличение мин. данных в листе (сильная регуляризация)\n",
        "    \"min_split_gain\": 0.01768422649000459,\n",
        "    \"n_estimators\": 30000,  # Увеличим, т.к. уменьшили learning_rate\n",
        "    \"n_jobs\": 0,\n",
        "    \"num_leaves\": 31,  # Уменьшим до стандартного значения num_leaves\n",
        "    \"objective\": \"regression\",\n",
        "    \"random_state\": 42,\n",
        "    \"reg_alpha\": 2.3326872626500275,\n",
        "    \"reg_lambda\": 2,\n",
        "    \"subsample\": 0.75,  # Уменьшение доли строк\n",
        "    \"max_bin\": 249,\n",
        "    \"extra_trees\": False,\n",
        "    \"verbose\": -1,\n",
        "}"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "9ecfc69f",
      "metadata": {},
      "outputs": [],
      "source": [
        "lgbm_model = LGBMRegressor(**best_params)\n",
        "differential_stopping = SimpleGapStopping(metric_name=\"rmse\", gap_threshold=1.3)\n",
        "\n",
        "lgbm_model.fit(\n",
        "    X_train,\n",
        "    y_train,\n",
        "    eval_set=[(X_train, y_train), (X_valid, y_valid)],\n",
        "    eval_metric=[\"rmse\", \"mape\", \"mae\"],\n",
        "    callbacks=[\n",
        "        early_stopping(stopping_rounds=300),\n",
        "        differential_stopping,\n",
        "        log_evaluation(200),\n",
        "    ],\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "a44fa704",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(\n",
        "    \"Train\",\n",
        "    compute_metrics((y_train), (lgbm_model.predict(X_train))),\n",
        ")\n",
        "print(\n",
        "    \"Valid\",\n",
        "    compute_metrics(y_valid, (lgbm_model.predict(X_valid))),\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5f6ac76a",
      "metadata": {},
      "outputs": [],
      "source": [
        "X_train.shape[0], X_valid.shape[0]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "aa968904",
      "metadata": {},
      "outputs": [],
      "source": [
        "explainer = shap.Explainer(\n",
        "    lgbm_model, feature_perturbation=\"tree_path_dependent\"\n",
        ")\n",
        "shap_values = explainer(X_valid)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d8488187",
      "metadata": {},
      "outputs": [],
      "source": [
        "shap.summary_plot(shap_values, X_valid, max_display=X_valid.shape[1])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "4002eab9",
      "metadata": {},
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "04251186",
      "metadata": {},
      "outputs": [],
      "source": [
        "import pickle\n",
        "\n",
        "\n",
        "# with open(\"./models/lgbm_model_base.pkl\", \"wb+\") as f:\n",
        "#     pickle.dump(lgbm_model, f)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "4c0d86c9",
      "metadata": {},
      "source": [
        "# Model TargetLog\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "7da0aa64",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = pd.read_csv(\"./data/after_eda.csv\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c13d8803",
      "metadata": {},
      "outputs": [],
      "source": [
        "SHUFFLE = True\n",
        "TEST_SIZE = 0.25\n",
        "RANDOM_STATE = 42"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "07fa1882",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.sort_values(\"deal_date\", inplace=True)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "48a10b88",
      "metadata": {},
      "outputs": [],
      "source": [
        "TARGET = \"price_usd_per_m2\"\n",
        "TARGET_LOG = \"log1p_price_usd_per_m2\""
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "6926c007",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.drop(columns=[\"inventory_id\", \"deal_date\"], inplace=True)\n",
        "\n",
        "Y = df[TARGET_LOG]\n",
        "X = df.drop(columns=[TARGET, TARGET_LOG])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "43f473e5",
      "metadata": {},
      "outputs": [],
      "source": [
        "cat_cols = [\n",
        "    \"property_type\",\n",
        "    \"wall_material\",\n",
        "    \"transferred_share\",\n",
        "    \"category\",\n",
        "    \"for_clusters_gr\",\n",
        "    \"Name NP\",\n",
        "    \"region_name\",\n",
        "    \"oblast_name\",\n",
        "    \"cluster\",\n",
        "]\n",
        "cat_idx = [X.columns.get_loc(c) for c in cat_cols]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "3ace75af",
      "metadata": {},
      "outputs": [],
      "source": [
        "X_train, X_valid, y_train, y_valid = train_test_split(\n",
        "    X, Y, test_size=TEST_SIZE, random_state=RANDOM_STATE, shuffle=SHUFFLE\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "298a8f8a",
      "metadata": {},
      "outputs": [],
      "source": [
        "X_train[cat_cols] = X_train[cat_cols].astype(\"category\")\n",
        "X_valid[cat_cols] = X_valid[cat_cols].astype(\"category\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "e632d49f",
      "metadata": {},
      "outputs": [],
      "source": [
        "sns.histplot(y_train)\n",
        "sns.histplot(y_valid)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "baa10c95",
      "metadata": {},
      "outputs": [],
      "source": [
        "best_params = {\n",
        "    \"boosting_type\": \"gbdt\",\n",
        "    \"colsample_bytree\": 0.6,\n",
        "    \"importance_type\": \"split\",\n",
        "    \"learning_rate\": 0.018452644928370358,\n",
        "    \"max_depth\": 8,\n",
        "    \"min_child_samples\": 11,\n",
        "    \"min_child_weight\": 4.175410890723387,\n",
        "    \"min_split_gain\": 0.01768422649000459,\n",
        "    \"n_estimators\": 20000,\n",
        "    \"n_jobs\": 0,\n",
        "    \"num_leaves\": 63,\n",
        "    \"objective\": \"regression\",\n",
        "    \"random_state\": 42,\n",
        "    \"reg_alpha\": 2.3326872626500275,\n",
        "    \"reg_lambda\": 2,\n",
        "    \"subsample\": 0.8,\n",
        "    \"max_bin\": 249,\n",
        "    \"extra_trees\": False,\n",
        "    \"verbose\": -1,\n",
        "}"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "43f1e032",
      "metadata": {},
      "outputs": [],
      "source": [
        "lgbm_model = LGBMRegressor(**best_params)\n",
        "differential_stopping = SimpleGapStopping(metric_name=\"rmse\", gap_threshold=1.5)\n",
        "\n",
        "lgbm_model.fit(\n",
        "    X_train,\n",
        "    y_train,\n",
        "    eval_set=[\n",
        "        (X_train, y_train),\n",
        "        (X_valid, y_valid),\n",
        "    ],\n",
        "    eval_metric=[\"rmse\"],\n",
        "    callbacks=[\n",
        "        early_stopping(\n",
        "            stopping_rounds=300,\n",
        "        ),\n",
        "        differential_stopping,\n",
        "        log_evaluation(200),\n",
        "    ],\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "87fbe490",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(\n",
        "    \"Train\",\n",
        "    compute_metrics(np.expm1(y_train), np.expm1(lgbm_model.predict(X_train))),\n",
        ")\n",
        "print(\n",
        "    \"Valid\",\n",
        "    compute_metrics(np.expm1(y_valid), np.expm1(lgbm_model.predict(X_valid))),\n",
        ")"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "936ec2b3",
      "metadata": {},
      "source": [
        "Train {'rmse': 203.84232135103298, 'mse': 41551.69197377779, 'mae': 111.46478050401912, 'mape*%': 128.09364609006508, 'median_mape*%': 31.86242030600316, 'smape\\_%': 45.13743681105628}\n",
        "\n",
        "Valid {'rmse': 252.2057734342869, 'mse': 63607.75215358685, 'mae': 145.4862162062353, 'mape*%': 305.73118067170253, 'median_mape*%': 44.89100410714622, 'smape\\_%': 61.949851023129874}\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8ab374ac",
      "metadata": {},
      "outputs": [],
      "source": [
        "X_train.shape[0], X_valid.shape[0]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "2e8e568f",
      "metadata": {},
      "outputs": [],
      "source": [
        "len(y_valid)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "fada8819",
      "metadata": {},
      "outputs": [],
      "source": [
        "np.expm1(Y).describe()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5e842c1d",
      "metadata": {},
      "outputs": [],
      "source": [
        "explainer = shap.Explainer(\n",
        "    lgbm_model, feature_perturbation=\"tree_path_dependent\"\n",
        ")\n",
        "shap_values = explainer(X_valid)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "aa113708",
      "metadata": {},
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f4c1d4be",
      "metadata": {},
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8995493e",
      "metadata": {},
      "outputs": [],
      "source": [
        "import pickle\n",
        "\n",
        "\n",
        "# with open(\"./models/lgbm_model_log_target_1.pkl\", \"wb+\") as f:\n",
        "#     pickle.dump(lgbm_model, f)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "fc76cdb5",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(\n",
        "    \"Train\",\n",
        "    compute_metrics(np.expm1(y_train), np.expm1(lgbm_model.predict(X_train))),\n",
        ")\n",
        "print(\n",
        "    \"Valid\",\n",
        "    compute_metrics(np.expm1(y_valid), np.expm1(lgbm_model.predict(X_valid))),\n",
        ")"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "55e34437",
      "metadata": {},
      "source": [
        "# Check Segments Metrics\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "65fd9eb7",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = pd.read_csv(\"./data/after_eda.csv\")\n",
        "cat_cols = [\n",
        "    \"property_type\",\n",
        "    \"wall_material\",\n",
        "    \"transferred_share\",\n",
        "    \"category\",\n",
        "    \"for_clusters_gr\",\n",
        "    \"Name NP\",\n",
        "    \"region_name\",\n",
        "    \"oblast_name\",\n",
        "    \"cluster\",\n",
        "]\n",
        "df[cat_cols] = df[cat_cols].astype(\"category\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c726ff8e",
      "metadata": {},
      "outputs": [],
      "source": [
        "SHUFFLE = True\n",
        "TEST_SIZE = 0.25\n",
        "RANDOM_STATE = 42"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "e54a6648",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.sort_values(\"deal_date\", inplace=True)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "40398a4d",
      "metadata": {},
      "outputs": [],
      "source": [
        "TARGET = \"price_usd_per_m2\"\n",
        "TARGET_LOG = \"log1p_price_usd_per_m2\""
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "33152ddc",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.drop(columns=[\"inventory_id\", \"deal_date\"], inplace=True)\n",
        "\n",
        "Y = df[TARGET_LOG]\n",
        "X = df.drop(columns=[TARGET, TARGET_LOG])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "4e5efa8a",
      "metadata": {},
      "outputs": [],
      "source": [
        "X_train, X_valid, y_train, y_valid = train_test_split(\n",
        "    X, Y, test_size=TEST_SIZE, random_state=RANDOM_STATE, shuffle=SHUFFLE\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "393efeb6",
      "metadata": {},
      "outputs": [],
      "source": [
        "with open(\"./models/lgbm_model_log_target.pkl\", \"rb\") as f:\n",
        "    lgbm_model_log = pickle.load(f)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "564967c8",
      "metadata": {},
      "source": [
        "## 1. Рассмотреть отдельно прогнозы на train/test - построить распределения, оценить мат-параметры.\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "47b1eb7b",
      "metadata": {},
      "outputs": [],
      "source": [
        "y_train_pred = np.expm1(lgbm_model_log.predict(X_train))\n",
        "y_valid_pred = np.expm1(lgbm_model_log.predict(X_valid))\n",
        "\n",
        "plt.figure(figsize=(12, 5))\n",
        "sns.histplot(y_train_pred, color=\"blue\", label=\"Train Predictions\", kde=True)\n",
        "sns.histplot(y_valid_pred, color=\"orange\", label=\"Valid Predictions\", kde=True)\n",
        "# sns.histplot(np.expm1(Y), color=\"green\", label=\"Valid Predictions\", kde=True)\n",
        "plt.legend()\n",
        "plt.title(\"Распределение прогнозов модели\")\n",
        "plt.show()\n",
        "\n",
        "train_info = pd.Series(y_train_pred).quantile(\n",
        "    [0.01, 0.05, 0.1, 0.9, 0.95, 0.99]\n",
        ")\n",
        "train_info[\"median\"] = np.median(y_train_pred)\n",
        "train_info[\"mean\"] = np.mean(y_train_pred)\n",
        "train_info[\"std\"] = np.std(y_train_pred)\n",
        "\n",
        "valid_info = pd.Series(y_valid_pred).quantile(\n",
        "    [0.01, 0.05, 0.1, 0.9, 0.95, 0.99]\n",
        ")\n",
        "valid_info[\"median\"] = np.median(y_valid_pred)\n",
        "valid_info[\"mean\"] = np.mean(y_valid_pred)\n",
        "valid_info[\"std\"] = np.std(y_valid_pred)\n",
        "\n",
        "print(\"TRAIN\")\n",
        "print(train_info)\n",
        "print(\"TEST\")\n",
        "print(valid_info)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "daae9a54",
      "metadata": {},
      "source": [
        "Разделять по верхнему точно плохая идея, в EDA уже отделил хорошую часть данных, лучше изменять только нижнюю\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "afb3cfaf",
      "metadata": {},
      "outputs": [],
      "source": [
        "segment_cols = [\n",
        "    \"property_type\",\n",
        "    # \"Name NP\",\n",
        "    \"region_name\",\n",
        "    \"wall_material\",\n",
        "    \"cluster\",\n",
        "    \"category\",\n",
        "    \"floors_below\",\n",
        "    \"for_clusters_gr\",\n",
        "    \"oblast_name\",\n",
        "]\n",
        "outliers_summary = []"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8191db92",
      "metadata": {},
      "outputs": [],
      "source": [
        "outliers_summary = []\n",
        "\n",
        "for seg in tqdm(segment_cols):\n",
        "    counts_train = X_train[seg].value_counts()\n",
        "    counts_valid = X_valid[seg].value_counts()\n",
        "\n",
        "    # Пропускаем малые группы\n",
        "    valid_groups = counts_train[counts_train >= 150].index\n",
        "    if len(valid_groups) == 0:\n",
        "        continue\n",
        "\n",
        "    for grp in valid_groups:\n",
        "        # Train\n",
        "        mask_train = X_train[seg] == grp\n",
        "        y_pred_train = np.expm1(lgbm_model_log.predict(X_train[mask_train]))\n",
        "        q_train = (\n",
        "            pd.Series(y_pred_train)\n",
        "            .quantile([0.01, 0.05, 0.1, 0.9, 0.95, 0.99])\n",
        "            .to_dict()\n",
        "        )\n",
        "        outliers_summary.append(\n",
        "            {\n",
        "                \"segment\": seg,\n",
        "                \"group\": grp,\n",
        "                \"dataset\": \"train\",\n",
        "                \"q1\": q_train[0.01],\n",
        "                \"q5\": q_train[0.05],\n",
        "                \"q10\": q_train[0.1],\n",
        "                \"q90\": q_train[0.9],\n",
        "                \"q95\": q_train[0.95],\n",
        "                \"q99\": q_train[0.99],\n",
        "            }\n",
        "        )\n",
        "\n",
        "        # Valid\n",
        "        mask_valid = X_valid[seg] == grp\n",
        "        y_pred_valid = np.expm1(lgbm_model_log.predict(X_valid[mask_valid]))\n",
        "        q_valid = (\n",
        "            pd.Series(y_pred_valid)\n",
        "            .quantile([0.01, 0.05, 0.1, 0.9, 0.95, 0.99])\n",
        "            .to_dict()\n",
        "        )\n",
        "        outliers_summary.append(\n",
        "            {\n",
        "                \"segment\": seg,\n",
        "                \"group\": grp,\n",
        "                \"dataset\": \"valid\",\n",
        "                \"q1\": q_valid[0.01],\n",
        "                \"q5\": q_valid[0.05],\n",
        "                \"q10\": q_valid[0.1],\n",
        "                \"q90\": q_valid[0.9],\n",
        "                \"q95\": q_valid[0.95],\n",
        "                \"q99\": q_valid[0.99],\n",
        "            }\n",
        "        )\n",
        "        # Full\n",
        "        mask_full = X[seg] == grp\n",
        "        y_pred_full = np.expm1(lgbm_model_log.predict(X[mask_full]))\n",
        "        q_full = (\n",
        "            pd.Series(y_pred_full)\n",
        "            .quantile([0.01, 0.05, 0.1, 0.9, 0.95, 0.99])\n",
        "            .to_dict()\n",
        "        )\n",
        "        outliers_summary.append(\n",
        "            {\n",
        "                \"segment\": seg,\n",
        "                \"group\": grp,\n",
        "                \"dataset\": \"full\",\n",
        "                \"q1\": q_full[0.01],\n",
        "                \"q5\": q_full[0.05],\n",
        "                \"q10\": q_full[0.1],\n",
        "                \"q90\": q_full[0.9],\n",
        "                \"q95\": q_full[0.95],\n",
        "                \"q99\": q_full[0.99],\n",
        "            }\n",
        "        )\n",
        "\n",
        "outliers_df = pd.DataFrame(outliers_summary)\n",
        "# display(outliers_df)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "99c0b9b6",
      "metadata": {},
      "outputs": [],
      "source": [
        "outliers_df.head()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5e26ea68",
      "metadata": {},
      "outputs": [],
      "source": [
        "quantiles = [\"q1\", \"q5\", \"q10\", \"q90\", \"q95\", \"q99\"]\n",
        "\n",
        "for seg in outliers_df[\"segment\"].unique():\n",
        "    df_seg = outliers_df[outliers_df[\"segment\"] == seg]\n",
        "\n",
        "    df_melt = df_seg.melt(\n",
        "        id_vars=[\"group\", \"dataset\", \"segment\"],\n",
        "        value_vars=quantiles,\n",
        "        var_name=\"quantile\",\n",
        "        value_name=\"value\",\n",
        "    )\n",
        "\n",
        "    g = sns.catplot(\n",
        "        data=df_melt,\n",
        "        x=\"group\",\n",
        "        y=\"value\",\n",
        "        hue=\"quantile\",\n",
        "        col=\"dataset\",\n",
        "        kind=\"bar\",\n",
        "        height=6,\n",
        "        aspect=1.5,\n",
        "    )\n",
        "    g.set_xticklabels(rotation=45)\n",
        "    g.set_titles(\"{col_name}\")\n",
        "    g.set_axis_labels(\"Группа\", \"Значение квантили (log)\")\n",
        "    plt.yscale(\"log\")  # логарифмическая шкала\n",
        "    g.fig.suptitle(f\"Квантили прогнозов по группам сегмента '{seg}'\", y=1.05)\n",
        "    plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "8e3dd373",
      "metadata": {},
      "source": [
        "### Проверим качество при замене аутлейров на всей выборке\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "4960957f",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = pd.read_csv(\"./data/after_eda.csv\")\n",
        "SHUFFLE = True\n",
        "TEST_SIZE = 0.25\n",
        "RANDOM_STATE = 42\n",
        "df.sort_values(\"deal_date\", inplace=True)\n",
        "TARGET = \"price_usd_per_m2\"\n",
        "TARGET_LOG = \"log1p_price_usd_per_m2\"\n",
        "df.drop(columns=[\"inventory_id\", \"deal_date\"], inplace=True)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f32c2e5f",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[TARGET].quantile([0.01, 0.05, 0.1, 0.9, 0.95])"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "89aa6fc1",
      "metadata": {},
      "source": [
        "Попробуем до 10 заменить на этот квантиль\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c71105a0",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(\"Будет изменено\", df[df[TARGET] < 5.96].shape[0])\n",
        "df[TARGET] = np.where(df[TARGET] < 5.96, 5.96, df[TARGET])\n",
        "df[TARGET_LOG] = np.log1p(df[TARGET])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "496ece0e",
      "metadata": {},
      "outputs": [],
      "source": [
        "Y = df[TARGET_LOG]\n",
        "X = df.drop(columns=[TARGET, TARGET_LOG])\n",
        "cat_cols = [\n",
        "    \"property_type\",\n",
        "    \"wall_material\",\n",
        "    \"transferred_share\",\n",
        "    \"category\",\n",
        "    \"for_clusters_gr\",\n",
        "    \"Name NP\",\n",
        "    \"region_name\",\n",
        "    \"oblast_name\",\n",
        "    \"cluster\",\n",
        "]\n",
        "X[cat_cols] = X[cat_cols].astype(\"category\")\n",
        "\n",
        "cat_idx = [X.columns.get_loc(c) for c in cat_cols]\n",
        "X_train, X_valid, y_train, y_valid = train_test_split(\n",
        "    X, Y, test_size=TEST_SIZE, random_state=RANDOM_STATE, shuffle=SHUFFLE\n",
        ")\n",
        "X_train[cat_cols] = X_train[cat_cols].astype(\"category\")\n",
        "X_valid[cat_cols] = X_valid[cat_cols].astype(\"category\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c45024d9",
      "metadata": {},
      "outputs": [],
      "source": [
        "# сначала проверим качество уже обученной модели\n",
        "print(\n",
        "    \"TRAIN\",\n",
        "    compute_metrics(\n",
        "        np.expm1(y_train), np.expm1(lgbm_model_log.predict(X_train))\n",
        "    ),\n",
        ")\n",
        "print(\n",
        "    \"TEST\",\n",
        "    compute_metrics(\n",
        "        np.expm1(y_valid), np.expm1(lgbm_model_log.predict(X_valid))\n",
        "    ),\n",
        ")\n",
        "print(\n",
        "    \"FULL\",\n",
        "    compute_metrics(np.expm1(Y), np.expm1(lgbm_model_log.predict(X))),\n",
        ")"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "8c5b563f",
      "metadata": {},
      "source": [
        "MAPE ~400 -> ~130\n"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "e3b133ff",
      "metadata": {},
      "source": [
        "#### LGBMRegressor 10Outliners_replaced\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "274a408e",
      "metadata": {},
      "outputs": [],
      "source": [
        "# теперь попробуем обучить модель на изменненых данных\n",
        "best_params = {\n",
        "    \"boosting_type\": \"gbdt\",\n",
        "    \"colsample_bytree\": 0.6,\n",
        "    \"importance_type\": \"split\",\n",
        "    \"learning_rate\": 0.018452644928370358,\n",
        "    \"max_depth\": 8,\n",
        "    \"min_child_samples\": 11,\n",
        "    \"min_child_weight\": 4.175410890723387,\n",
        "    \"min_split_gain\": 0.01768422649000459,\n",
        "    \"n_estimators\": 20000,\n",
        "    \"n_jobs\": 0,\n",
        "    \"num_leaves\": 63,\n",
        "    \"objective\": \"regression\",\n",
        "    \"random_state\": 42,\n",
        "    \"reg_alpha\": 2.3326872626500275,\n",
        "    \"reg_lambda\": 2,\n",
        "    \"subsample\": 0.8,\n",
        "    \"max_bin\": 249,\n",
        "    \"extra_trees\": False,\n",
        "    \"verbose\": -1,\n",
        "}\n",
        "lgbm_model_10_outlined_log = LGBMRegressor(**best_params)\n",
        "differential_stopping = SimpleGapStopping(metric_name=\"rmse\", gap_threshold=1.5)\n",
        "\n",
        "lgbm_model_10_outlined_log.fit(\n",
        "    X_train,\n",
        "    y_train,\n",
        "    eval_set=[\n",
        "        (X_train, y_train),\n",
        "        (X_valid, y_valid),\n",
        "    ],\n",
        "    eval_metric=[\"rmse\"],\n",
        "    callbacks=[\n",
        "        early_stopping(\n",
        "            stopping_rounds=300,\n",
        "        ),\n",
        "        differential_stopping,\n",
        "        log_evaluation(200),\n",
        "    ],\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "bb59105b",
      "metadata": {},
      "outputs": [],
      "source": [
        "# сначала проверим качество уже обученной модели\n",
        "print(\n",
        "    \"TRAIN\",\n",
        "    compute_metrics(\n",
        "        np.expm1(y_train), np.expm1(lgbm_model_10_outlined_log.predict(X_train))\n",
        "    ),\n",
        ")\n",
        "print(\n",
        "    \"TEST\",\n",
        "    compute_metrics(\n",
        "        np.expm1(y_valid), np.expm1(lgbm_model_10_outlined_log.predict(X_valid))\n",
        "    ),\n",
        ")\n",
        "print(\n",
        "    \"FULL\",\n",
        "    compute_metrics(\n",
        "        np.expm1(Y), np.expm1(lgbm_model_10_outlined_log.predict(X))\n",
        "    ),\n",
        ")"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "f1e869f3",
      "metadata": {},
      "source": [
        "#### Catboost\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "14e9c2af",
      "metadata": {},
      "outputs": [],
      "source": [
        "# X_train[cat_cols] = X_train[cat_cols].astype(str).fillna(\"NaN\")\n",
        "# X_valid[cat_cols] = X_valid[cat_cols].astype(str).fillna(\"NaN\")\n",
        "# train_pool = Pool(X_train, y_train, cat_features=cat_cols)\n",
        "# valid_pool = Pool(X_valid, y_valid, cat_features=cat_cols)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c50affe4",
      "metadata": {},
      "outputs": [],
      "source": [
        "# # теперь попробуем обучить модель на изменненых данных\n",
        "# cb_model_10_outlined_log = CatBoostRegressor(learning_rate=1e-3)\n",
        "# # differential_stopping = SimpleGapStopping(metric_name=\"rmse\", gap_threshold=1.5)\n",
        "\n",
        "# cb_model_10_outlined_log.fit(\n",
        "#     train_pool,\n",
        "#     eval_set=valid_pool,\n",
        "#     use_best_model=True,\n",
        "#     verbose=200,\n",
        "# )"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "daf09276",
      "metadata": {},
      "outputs": [],
      "source": [
        "# # сначала проверим качество уже обученной модели\n",
        "# print(\n",
        "#     \"TRAIN\",\n",
        "#     compute_metrics(\n",
        "#         np.expm1(y_train), np.expm1(cb_model_10_outlined_log.predict(X_train))\n",
        "#     ),\n",
        "# )\n",
        "# print(\n",
        "#     \"TEST\",\n",
        "#     compute_metrics(\n",
        "#         np.expm1(y_valid), np.expm1(cb_model_10_outlined_log.predict(X_valid))\n",
        "#     ),\n",
        "# )\n",
        "# # print(\n",
        "# #     \"FULL\",\n",
        "# #     compute_metrics(np.expm1(Y), np.expm1(cb_model_10_outlined_log.predict(X))),\n",
        "# # )"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "df15f7bc",
      "metadata": {},
      "source": [
        "#### SHAP\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "6fe48081",
      "metadata": {},
      "outputs": [],
      "source": [
        "explainer = shap.Explainer(\n",
        "    lgbm_model_10_outlined_log, feature_perturbation=\"tree_path_dependent\"\n",
        ")\n",
        "shap_values = explainer(X_valid)\n",
        "shap.summary_plot(shap_values, X_valid, max_display=X_valid.shape[1])"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "6c31e1ed",
      "metadata": {},
      "source": [
        "#### Выводы на обучении при замене на 10 перцентиль\n",
        "\n",
        "Модель на лог таргете получила сильно лучше значения относительных метрик, абсолютные сильно не изменились, что логично\n",
        "Изменения MAPE: Train (252 -> 57), Test (1000 -> 108) Full (~400 -> 70)\n"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c39c8d4e",
      "metadata": {},
      "source": [
        "Ниже проверим качество на сегментах (сначала на всем датасете), а потом на train/test\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5d786086",
      "metadata": {},
      "outputs": [],
      "source": [
        "results = []\n",
        "\n",
        "# Один раз вычисляем exp\n",
        "y_true_full = np.expm1(Y)\n",
        "segment_cols = [\n",
        "    \"property_type\",\n",
        "    \"Name NP\",\n",
        "    \"region_name\",\n",
        "    \"wall_material\",\n",
        "    \"cluster\",\n",
        "    \"category\",\n",
        "    \"floors_below\",\n",
        "    \"for_clusters_gr\",\n",
        "    \"oblast_name\",\n",
        "]\n",
        "\n",
        "for col in segment_cols:\n",
        "    for val in tqdm(X[col].unique(), desc=col):\n",
        "        if pd.isna(val):\n",
        "            mask = X[col].isna()  # выбираем все NaN\n",
        "            segment_val = \"NaN\"\n",
        "        else:\n",
        "            mask = X[col] == val\n",
        "            segment_val = val\n",
        "\n",
        "        y_true = y_true_full[mask]\n",
        "        X_seg = X.loc[mask]\n",
        "\n",
        "        y_pred = np.expm1(lgbm_model_10_outlined_log.predict(X_seg))\n",
        "        metrics = compute_metrics(y_true, y_pred)\n",
        "\n",
        "        results.append(\n",
        "            {\n",
        "                \"segment_col\": col,\n",
        "                \"segment_val\": segment_val,\n",
        "                \"n_samples\": len(X_seg),\n",
        "                **metrics,\n",
        "            }\n",
        "        )\n",
        "\n",
        "results_df = pd.DataFrame(results)\n",
        "print(results_df.shape)\n",
        "results_df = results_df[results_df[\"n_samples\"] > 100]\n",
        "print(results_df.shape)\n",
        "metrics = [\"mae\", \"mape_%\", \"median_mape_%\", \"smape_%\"]\n",
        "\n",
        "for segment_col in segment_cols:\n",
        "    df_col = results_df[results_df[\"segment_col\"] == segment_col]\n",
        "\n",
        "    # подписи с количеством сэмплов\n",
        "    x_labels = [\n",
        "        f\"{val}\\n(n={df_col[df_col['segment_val'] == val]['n_samples'].iloc[0]})\"\n",
        "        for val in df_col[\"segment_val\"].unique()\n",
        "    ]\n",
        "\n",
        "    unique_vals = df_col[\"segment_val\"].unique()\n",
        "    colors = sns.color_palette(\"tab20\", n_colors=len(unique_vals))\n",
        "    palette = dict(zip(unique_vals, colors))\n",
        "\n",
        "    fig, axes = plt.subplots(1, len(metrics), figsize=(19 * len(metrics), 8))\n",
        "\n",
        "    if len(metrics) == 1:\n",
        "        axes = [axes]\n",
        "\n",
        "    for col_idx, metric in enumerate(metrics):\n",
        "        ax = axes[col_idx]\n",
        "        sns.barplot(\n",
        "            data=df_col,\n",
        "            x=\"segment_val\",\n",
        "            y=metric,\n",
        "            hue=\"segment_val\",\n",
        "            palette=palette,\n",
        "            dodge=False,\n",
        "            ax=ax,\n",
        "        )\n",
        "        ax.set_title(f\"{segment_col} – {metric.upper()}\")\n",
        "        ax.set_xticks(np.arange(len(x_labels)))\n",
        "        ax.set_xticklabels(x_labels, rotation=45)\n",
        "\n",
        "    fig.suptitle(f\"Метрики для сегмента {segment_col}\", fontsize=16)\n",
        "    plt.subplots_adjust(top=0.85)\n",
        "    plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c601dd7f",
      "metadata": {},
      "source": [
        "#### Выводы по метрикам по сегментам:\n",
        "\n",
        "При замене на 10q исчезло выделение сегментов по относительным метрикам, они +- стали равны в качестве, за исключением некоторых значений в связи:\n",
        "\n",
        "- возможно маленькое кол-во данных\n",
        "-\n"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "6f592dba",
      "metadata": {},
      "source": [
        "### Проверим качество при удалении аутлейров на всей выборке\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "766fde26",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = pd.read_csv(\"./data/after_eda.csv\")\n",
        "SHUFFLE = True\n",
        "TEST_SIZE = 0.25\n",
        "RANDOM_STATE = 42\n",
        "df.sort_values(\"deal_date\", inplace=True)\n",
        "TARGET = \"price_usd_per_m2\"\n",
        "TARGET_LOG = \"log1p_price_usd_per_m2\"\n",
        "df.drop(columns=[\"inventory_id\", \"deal_date\"], inplace=True)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "ce43cb3d",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[TARGET].quantile([0.01, 0.05, 0.1, 0.9, 0.95])"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "50eb9261",
      "metadata": {},
      "source": [
        "Попробуем удалить все до 10q\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "72966908",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(\"Будет удалено\", df[df[TARGET] < 5.96].shape[0])\n",
        "df = df[df[TARGET] > 5.96]\n",
        "df[TARGET_LOG] = np.log1p(df[TARGET])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "90a71a0c",
      "metadata": {},
      "outputs": [],
      "source": [
        "Y = df[TARGET_LOG]\n",
        "X = df.drop(columns=[TARGET, TARGET_LOG])\n",
        "cat_cols = [\n",
        "    \"property_type\",\n",
        "    \"wall_material\",\n",
        "    \"transferred_share\",\n",
        "    \"category\",\n",
        "    \"for_clusters_gr\",\n",
        "    \"Name NP\",\n",
        "    \"region_name\",\n",
        "    \"oblast_name\",\n",
        "    \"cluster\",\n",
        "]\n",
        "X[cat_cols] = X[cat_cols].astype(\"category\")\n",
        "\n",
        "cat_idx = [X.columns.get_loc(c) for c in cat_cols]\n",
        "X_train, X_valid, y_train, y_valid = train_test_split(\n",
        "    X, Y, test_size=TEST_SIZE, random_state=RANDOM_STATE, shuffle=SHUFFLE\n",
        ")\n",
        "X_train[cat_cols] = X_train[cat_cols].astype(\"category\")\n",
        "X_valid[cat_cols] = X_valid[cat_cols].astype(\"category\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "dc479f43",
      "metadata": {},
      "outputs": [],
      "source": [
        "# сначала проверим качество уже обученной модели\n",
        "print(\n",
        "    \"TRAIN\",\n",
        "    compute_metrics(\n",
        "        np.expm1(y_train), np.expm1(lgbm_model_log.predict(X_train))\n",
        "    ),\n",
        ")\n",
        "print(\n",
        "    \"TEST\",\n",
        "    compute_metrics(\n",
        "        np.expm1(y_valid), np.expm1(lgbm_model_log.predict(X_valid))\n",
        "    ),\n",
        ")\n",
        "print(\n",
        "    \"FULL\",\n",
        "    compute_metrics(np.expm1(Y), np.expm1(lgbm_model_log.predict(X))),\n",
        ")"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "08ec6153",
      "metadata": {},
      "source": [
        "MAPE ~400 -> ~100\n"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "90464a23",
      "metadata": {},
      "source": [
        "#### LGBMRegressor 10Outliners_deleted\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "353a1c80",
      "metadata": {},
      "outputs": [],
      "source": [
        "# теперь попробуем обучить модель на изменненых данных\n",
        "best_params = {\n",
        "    \"boosting_type\": \"gbdt\",\n",
        "    \"colsample_bytree\": 0.6,\n",
        "    \"importance_type\": \"split\",\n",
        "    \"learning_rate\": 0.018452644928370358,\n",
        "    \"max_depth\": 8,\n",
        "    \"min_child_samples\": 11,\n",
        "    \"min_child_weight\": 4.175410890723387,\n",
        "    \"min_split_gain\": 0.01768422649000459,\n",
        "    \"n_estimators\": 20000,\n",
        "    \"n_jobs\": 0,\n",
        "    \"num_leaves\": 63,\n",
        "    \"objective\": \"regression\",\n",
        "    \"random_state\": 42,\n",
        "    \"reg_alpha\": 2.3326872626500275,\n",
        "    \"reg_lambda\": 2,\n",
        "    \"subsample\": 0.8,\n",
        "    \"max_bin\": 249,\n",
        "    \"extra_trees\": False,\n",
        "    \"verbose\": -1,\n",
        "}\n",
        "lgbm_model_10_outlined_deleted_log = LGBMRegressor(**best_params)\n",
        "differential_stopping = SimpleGapStopping(metric_name=\"rmse\", gap_threshold=1.5)\n",
        "\n",
        "lgbm_model_10_outlined_deleted_log.fit(\n",
        "    X_train,\n",
        "    y_train,\n",
        "    eval_set=[\n",
        "        (X_train, y_train),\n",
        "        (X_valid, y_valid),\n",
        "    ],\n",
        "    eval_metric=[\"rmse\"],\n",
        "    callbacks=[\n",
        "        early_stopping(\n",
        "            stopping_rounds=300,\n",
        "        ),\n",
        "        differential_stopping,\n",
        "        log_evaluation(200),\n",
        "    ],\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "adb70e20",
      "metadata": {},
      "outputs": [],
      "source": [
        "# сначала проверим качество уже обученной модели\n",
        "print(\n",
        "    \"TRAIN\",\n",
        "    compute_metrics(\n",
        "        np.expm1(y_train),\n",
        "        np.expm1(lgbm_model_10_outlined_deleted_log.predict(X_train)),\n",
        "    ),\n",
        ")\n",
        "print(\n",
        "    \"TEST\",\n",
        "    compute_metrics(\n",
        "        np.expm1(y_valid),\n",
        "        np.expm1(lgbm_model_10_outlined_deleted_log.predict(X_valid)),\n",
        "    ),\n",
        ")\n",
        "print(\n",
        "    \"FULL\",\n",
        "    compute_metrics(\n",
        "        np.expm1(Y), np.expm1(lgbm_model_10_outlined_deleted_log.predict(X))\n",
        "    ),\n",
        ")"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "74be0323",
      "metadata": {},
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "799bd553",
      "metadata": {},
      "outputs": [],
      "source": [
        "explainer = shap.Explainer(\n",
        "    lgbm_model_10_outlined_deleted_log,\n",
        "    feature_perturbation=\"tree_path_dependent\",\n",
        ")\n",
        "shap_values = explainer(X_valid)\n",
        "shap.summary_plot(shap_values, X_valid, max_display=X_valid.shape[1])"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "8efcf40a",
      "metadata": {},
      "source": [
        "#### LGBMRegressor 10Outliners_replaced deleted target\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "ed7e46b2",
      "metadata": {},
      "outputs": [],
      "source": [
        "# теперь попробуем обучить модель на изменненых данных\n",
        "best_params = {\n",
        "    \"boosting_type\": \"gbdt\",\n",
        "    \"colsample_bytree\": 0.6,\n",
        "    \"importance_type\": \"split\",\n",
        "    \"learning_rate\": 0.018452644928370358,\n",
        "    \"max_depth\": 8,\n",
        "    \"min_child_samples\": 11,\n",
        "    \"min_child_weight\": 4.175410890723387,\n",
        "    \"min_split_gain\": 0.01768422649000459,\n",
        "    \"n_estimators\": 20000,\n",
        "    \"n_jobs\": 0,\n",
        "    \"num_leaves\": 63,\n",
        "    \"objective\": \"regression\",\n",
        "    \"random_state\": 42,\n",
        "    \"reg_alpha\": 2.3326872626500275,\n",
        "    \"reg_lambda\": 2,\n",
        "    \"subsample\": 0.8,\n",
        "    \"max_bin\": 249,\n",
        "    \"extra_trees\": False,\n",
        "    \"verbose\": -1,\n",
        "}\n",
        "lgbm_model_10_outlined_deleted = LGBMRegressor(**best_params)\n",
        "differential_stopping = SimpleGapStopping(metric_name=\"mape\", gap_threshold=1.5)\n",
        "y_train_expm1 = np.expm1(y_train)\n",
        "y_valid_expm1 = np.expm1(y_valid)\n",
        "\n",
        "lgbm_model_10_outlined_deleted.fit(\n",
        "    X_train,\n",
        "    y_train_expm1,\n",
        "    eval_set=[\n",
        "        (X_train, y_train_expm1),\n",
        "        (X_valid, y_valid_expm1),\n",
        "    ],\n",
        "    eval_metric=\"mape\",\n",
        "    callbacks=[\n",
        "        early_stopping(\n",
        "            stopping_rounds=300,\n",
        "        ),\n",
        "        differential_stopping,\n",
        "        log_evaluation(200),\n",
        "    ],\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "a88c700c",
      "metadata": {},
      "outputs": [],
      "source": [
        "# сначала проверим качество уже обученной модели\n",
        "print(\n",
        "    \"TRAIN\",\n",
        "    compute_metrics(\n",
        "        np.expm1(y_train), (lgbm_model_10_outlined_deleted.predict(X_train))\n",
        "    ),\n",
        ")\n",
        "print(\n",
        "    \"TEST\",\n",
        "    compute_metrics(\n",
        "        np.expm1(y_valid), (lgbm_model_10_outlined_deleted.predict(X_valid))\n",
        "    ),\n",
        ")\n",
        "print(\n",
        "    \"FULL\",\n",
        "    compute_metrics(np.expm1(Y), (lgbm_model_10_outlined_deleted.predict(X))),\n",
        ")"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "0b0e2c39",
      "metadata": {},
      "source": [
        "#### Выводы на обучении при удалении до 10q\n",
        "\n",
        "Изменения MAPE: Train (252 -> 52), Test (1000 -> 101) Full (~400 -> 65)\n"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "8e3d84a8",
      "metadata": {},
      "source": [
        "Ниже проверим качество на сегментах (сначала на всем датасете), а потом на train/test\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8ab3226d",
      "metadata": {},
      "outputs": [],
      "source": [
        "results = []\n",
        "\n",
        "# Один раз вычисляем exp\n",
        "y_true_full = np.expm1(Y)\n",
        "segment_cols = [\n",
        "    \"property_type\",\n",
        "    \"Name NP\",\n",
        "    \"region_name\",\n",
        "    \"wall_material\",\n",
        "    \"cluster\",\n",
        "    \"category\",\n",
        "    \"floors_below\",\n",
        "    \"for_clusters_gr\",\n",
        "    \"oblast_name\",\n",
        "]\n",
        "\n",
        "for col in segment_cols:\n",
        "    for val in tqdm(X[col].unique(), desc=col):\n",
        "        if pd.isna(val):\n",
        "            mask = X[col].isna()  # выбираем все NaN\n",
        "            segment_val = \"NaN\"\n",
        "        else:\n",
        "            mask = X[col] == val\n",
        "            segment_val = val\n",
        "\n",
        "        y_true = y_true_full[mask]\n",
        "        X_seg = X.loc[mask]\n",
        "\n",
        "        y_pred = np.expm1(lgbm_model_10_outlined_deleted_log.predict(X_seg))\n",
        "        metrics = compute_metrics(y_true, y_pred)\n",
        "\n",
        "        results.append(\n",
        "            {\n",
        "                \"segment_col\": col,\n",
        "                \"segment_val\": segment_val,\n",
        "                \"n_samples\": len(X_seg),\n",
        "                **metrics,\n",
        "            }\n",
        "        )\n",
        "\n",
        "results_df = pd.DataFrame(results)\n",
        "print(results_df.shape)\n",
        "results_df = results_df[results_df[\"n_samples\"] > 100]\n",
        "print(results_df.shape)\n",
        "metrics = [\"mae\", \"mape_%\", \"median_mape_%\", \"smape_%\"]\n",
        "\n",
        "for segment_col in segment_cols:\n",
        "    df_col = results_df[results_df[\"segment_col\"] == segment_col]\n",
        "\n",
        "    # подписи с количеством сэмплов\n",
        "    x_labels = [\n",
        "        f\"{val}\\n(n={df_col[df_col['segment_val'] == val]['n_samples'].iloc[0]})\"\n",
        "        for val in df_col[\"segment_val\"].unique()\n",
        "    ]\n",
        "\n",
        "    unique_vals = df_col[\"segment_val\"].unique()\n",
        "    colors = sns.color_palette(\"tab20\", n_colors=len(unique_vals))\n",
        "    palette = dict(zip(unique_vals, colors))\n",
        "\n",
        "    fig, axes = plt.subplots(1, len(metrics), figsize=(19 * len(metrics), 8))\n",
        "\n",
        "    if len(metrics) == 1:\n",
        "        axes = [axes]\n",
        "\n",
        "    for col_idx, metric in enumerate(metrics):\n",
        "        ax = axes[col_idx]\n",
        "        sns.barplot(\n",
        "            data=df_col,\n",
        "            x=\"segment_val\",\n",
        "            y=metric,\n",
        "            hue=\"segment_val\",\n",
        "            palette=palette,\n",
        "            dodge=False,\n",
        "            ax=ax,\n",
        "        )\n",
        "        ax.set_title(f\"{segment_col} – {metric.upper()}\")\n",
        "        ax.set_xticks(np.arange(len(x_labels)))\n",
        "        ax.set_xticklabels(x_labels, rotation=45)\n",
        "\n",
        "    fig.suptitle(f\"Метрики для сегмента {segment_col}\", fontsize=16)\n",
        "    plt.subplots_adjust(top=0.85)\n",
        "    plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "b5737a6b",
      "metadata": {},
      "source": [
        "### Проверим качество на комбинациях\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "1d8abcc1",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = pd.read_csv(\"./data/after_eda.csv\")\n",
        "SHUFFLE = True\n",
        "TEST_SIZE = 0.25\n",
        "RANDOM_STATE = 42\n",
        "df.sort_values(\"deal_date\", inplace=True)\n",
        "TARGET = \"price_usd_per_m2\"\n",
        "TARGET_LOG = \"log1p_price_usd_per_m2\"\n",
        "df.drop(columns=[\"inventory_id\", \"deal_date\"], inplace=True)\n",
        "df[cat_cols] = df[cat_cols].astype(\"category\")\n",
        "df = df[df[TARGET] > 5.96]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "e714303d",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"pred\"] = np.expm1(\n",
        "    lgbm_model_10_outlined_log.predict(\n",
        "        df.drop(columns=[TARGET, TARGET_LOG, \"pred\"], errors=\"ignore\")\n",
        "    )\n",
        ")\n",
        "df[\"target\"] = df[TARGET].copy()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "e3c0ae15",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"MAPE\"] = 100 * (np.abs(df[\"target\"] - df[\"pred\"]) / df[\"target\"])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "541d22bd",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"MAPE\"].mean()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "393ba28a",
      "metadata": {},
      "outputs": [],
      "source": [
        "segment_cols = [\n",
        "    \"property_type\",\n",
        "    \"Name NP\",\n",
        "    \"region_name\",\n",
        "    \"wall_material\",\n",
        "    \"cluster\",\n",
        "    \"category\",\n",
        "    # \"for_clusters_gr\",\n",
        "    \"oblast_name\",\n",
        "]\n",
        "\n",
        "\n",
        "def find_best_combinations(df, segment_cols, min_samples=100):\n",
        "    all_results = []  # Сохраняем ВСЕ комбинации\n",
        "\n",
        "    # Генерируем все комбинации от 2 до 4 признаков\n",
        "    from itertools import combinations\n",
        "\n",
        "    all_combinations = []\n",
        "    for r in range(2, 4):  # От 2 до 3 признаков\n",
        "        all_combinations.extend(list(combinations(segment_cols, r)))\n",
        "\n",
        "    print(f\"Анализируем {len(all_combinations)} комбинаций признаков...\")\n",
        "\n",
        "    for combo in tqdm(all_combinations):\n",
        "        # Комбинация из нескольких признаков\n",
        "        combo_name = \"+\".join(combo)\n",
        "\n",
        "        # Создаем временный столбец с комбинацией\n",
        "        temp_col = \"temp_combo\"\n",
        "        df[temp_col] = \"\"\n",
        "        for col in combo:\n",
        "            df[temp_col] = df[temp_col] + df[col].astype(str) + \"_\"\n",
        "\n",
        "        # Анализируем каждую уникальную комбинацию\n",
        "        for combo_val in df[temp_col].unique():\n",
        "            mask = df[temp_col] == combo_val\n",
        "            segment_size = mask.sum()\n",
        "\n",
        "            segment_mape = df.loc[mask, \"MAPE\"].mean()\n",
        "\n",
        "            # Создаем читаемое описание сегмента\n",
        "            values = combo_val.rstrip(\"_\").split(\"_\")\n",
        "            segment_desc = \" | \".join(\n",
        "                [f\"{combo[i]} = {values[i]}\" for i in range(len(combo))]\n",
        "            )\n",
        "\n",
        "            all_results.append(\n",
        "                {\n",
        "                    \"combo\": combo_name,\n",
        "                    \"segment\": segment_desc,\n",
        "                    \"n_samples\": segment_size,\n",
        "                    \"mape\": segment_mape,\n",
        "                }\n",
        "            )\n",
        "\n",
        "        # Удаляем временный столбец\n",
        "        df.drop(columns=[temp_col], inplace=True)\n",
        "\n",
        "    # Возвращаем ВСЕ результаты\n",
        "    return pd.DataFrame(all_results)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c583594b",
      "metadata": {},
      "outputs": [],
      "source": [
        "all_combinations_df = find_best_combinations(df, segment_cols)\n",
        "\n",
        "# Фильтруем по минимальному размеру сегмента\n",
        "filtered_df = all_combinations_df[all_combinations_df[\"n_samples\"] >= 700]\n",
        "\n",
        "# Сохраняем все комбинации в файл\n",
        "all_combinations_df.to_excel(\n",
        "    \"./seg_analys/all_combinations_2_to_4.xlsx\", index=False\n",
        ")\n",
        "filtered_df.to_excel(\n",
        "    \"./seg_analys/filtered_combinations_2_to_4.xlsx\", index=False\n",
        ")\n",
        "\n",
        "# Выводим только лучшие сегменты\n",
        "print(\"ТОП-20 ЛУЧШИХ СЕГМЕНТОВ ПО MAPE:\")\n",
        "top_segments = filtered_df.nsmallest(20, \"mape\")\n",
        "\n",
        "for i, (idx, row) in enumerate(top_segments.iterrows(), 1):\n",
        "    print(\n",
        "        f\"{i:2d}. MAPE: {row['mape']:6.2f}% | Размер: {row['n_samples']} | \"\n",
        "        f\"Комбинация: {row['combo']:30} | Сегмент: {row['segment']}\"\n",
        "    )\n",
        "\n",
        "# Выводим лучшие комбинации признаков\n",
        "print(\"\\nТОП-10 ЛУЧШИХ КОМБИНАЦИЙ ПРИЗНАКОВ:\")\n",
        "combo_stats = (\n",
        "    filtered_df.groupby(\"combo\")\n",
        "    .agg({\"mape\": [\"mean\", \"min\", \"count\"], \"n_samples\": \"sum\"})\n",
        "    .round(2)\n",
        ")\n",
        "\n",
        "combo_stats.columns = [\"avg_mape\", \"min_mape\", \"n_segments\", \"total_samples\"]\n",
        "combo_stats = combo_stats.sort_values(\"avg_mape\")\n",
        "\n",
        "for i, (combo, stats) in enumerate(combo_stats.head(10).iterrows(), 1):\n",
        "    print(\n",
        "        f\"{i:2d}. Комбинация: {combo:30} | Средний MAPE: {stats['avg_mape']:6.2f}% | \"\n",
        "        f\"Лучший MAPE: {stats['min_mape']:6.2f}% | Сегментов: {stats['n_segments']}\"\n",
        "    )\n",
        "\n",
        "# Сохраняем топ-50 сегментов\n",
        "top_50_segments = filtered_df.nsmallest(50, \"mape\")\n",
        "top_50_segments.to_excel(\n",
        "    \"./seg_analys/top_50_segments_2_to_4.xlsx\", index=False\n",
        ")"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "578bb592",
      "metadata": {},
      "source": []
    },
    {
      "cell_type": "markdown",
      "id": "47504f28",
      "metadata": {},
      "source": [
        "## А теперь давай попробуем обрезать не по общему, а внутри сегмента\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "4207a313",
      "metadata": {},
      "outputs": [],
      "source": [
        "outliers_df[outliers_df[\"segment\"] == \"cluster\"]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "3aaa343f",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = pd.read_csv(\"./data/after_eda.csv\")\n",
        "SHUFFLE = True\n",
        "TEST_SIZE = 0.25\n",
        "RANDOM_STATE = 42\n",
        "df.sort_values(\"deal_date\", inplace=True)\n",
        "TARGET = \"price_usd_per_m2\"\n",
        "TARGET_LOG = \"log1p_price_usd_per_m2\"\n",
        "df.drop(columns=[\"inventory_id\", \"deal_date\"], inplace=True)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "ae3c54a5",
      "metadata": {},
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "cb78311b",
      "metadata": {},
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "markdown",
      "id": "3fd74c05",
      "metadata": {},
      "source": [
        "тут соберем выбросы для бизнеса\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "0c0301e1",
      "metadata": {},
      "outputs": [],
      "source": [
        "# df[df[TARGET] < q].to_excel(\"./results/outliers.xlsx\", index=False)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "6fd8b093",
      "metadata": {},
      "source": [
        "## 2. FeatureSelection\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "cab946f3",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = pd.read_csv(\"./data/after_eda.csv\")\n",
        "SHUFFLE = True\n",
        "TEST_SIZE = 0.25\n",
        "RANDOM_STATE = 42\n",
        "df.sort_values(\"deal_date\", inplace=True)\n",
        "TARGET = \"price_usd_per_m2\"\n",
        "TARGET_LOG = \"log1p_price_usd_per_m2\"\n",
        "df.drop(columns=[\"inventory_id\", \"deal_date\"], inplace=True)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "ba6f3f03",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(\"Будет изменено\", df[df[TARGET] < 5.96].shape[0])\n",
        "df[TARGET] = np.where(df[TARGET] < 5.96, 5.96, df[TARGET])\n",
        "df[TARGET_LOG] = np.log1p(df[TARGET])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "44b1b35c",
      "metadata": {},
      "outputs": [],
      "source": [
        "Y = df[TARGET_LOG]\n",
        "X = df.drop(columns=[TARGET, TARGET_LOG])\n",
        "cat_cols = [\n",
        "    \"property_type\",\n",
        "    \"wall_material\",\n",
        "    \"transferred_share\",\n",
        "    \"category\",\n",
        "    \"for_clusters_gr\",\n",
        "    \"Name NP\",\n",
        "    \"region_name\",\n",
        "    \"oblast_name\",\n",
        "    \"cluster\",\n",
        "]\n",
        "X[cat_cols] = X[cat_cols].astype(\"category\")\n",
        "\n",
        "cat_idx = [X.columns.get_loc(c) for c in cat_cols]\n",
        "X_train, X_valid, y_train, y_valid = train_test_split(\n",
        "    X, Y, test_size=TEST_SIZE, random_state=RANDOM_STATE, shuffle=SHUFFLE\n",
        ")\n",
        "X_train[cat_cols] = X_train[cat_cols].astype(\"category\")\n",
        "X_valid[cat_cols] = X_valid[cat_cols].astype(\"category\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "afbb7778",
      "metadata": {},
      "outputs": [],
      "source": [
        "# сначала проверим качество уже обученной модели\n",
        "print(\n",
        "    \"TRAIN\",\n",
        "    compute_metrics(\n",
        "        np.expm1(y_train), np.expm1(lgbm_model_10_outlined_log.predict(X_train))\n",
        "    ),\n",
        ")\n",
        "print(\n",
        "    \"TEST\",\n",
        "    compute_metrics(\n",
        "        np.expm1(y_valid), np.expm1(lgbm_model_10_outlined_log.predict(X_valid))\n",
        "    ),\n",
        ")\n",
        "print(\n",
        "    \"FULL\",\n",
        "    compute_metrics(\n",
        "        np.expm1(Y), np.expm1(lgbm_model_10_outlined_log.predict(X))\n",
        "    ),\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "ddb5b282",
      "metadata": {},
      "outputs": [],
      "source": [
        "explainer = shap.Explainer(\n",
        "    lgbm_model_10_outlined_log, feature_perturbation=\"tree_path_dependent\"\n",
        ")\n",
        "shap_values = explainer(X_valid)\n",
        "shap.summary_plot(shap_values, X_valid, max_display=X_valid.shape[1])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5ceee79d",
      "metadata": {},
      "outputs": [],
      "source": [
        "feature_importance = np.abs(shap_values.values).mean(0)\n",
        "feature_ranking = pd.Series(\n",
        "    feature_importance, index=X_valid.columns\n",
        ").sort_values(ascending=False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "1dd2f25b",
      "metadata": {},
      "outputs": [],
      "source": [
        "top_sizes = [10, 15, 20, 25, 30, 40]\n",
        "results = []\n",
        "\n",
        "for k in top_sizes:\n",
        "    top_features = feature_ranking.head(k).index.tolist()\n",
        "    print(top_features)\n",
        "    # обучаем модель только на топовых фичах\n",
        "    model = LGBMRegressor(**best_params)\n",
        "    model.fit(\n",
        "        X_train[top_features],\n",
        "        y_train,\n",
        "        eval_set=[\n",
        "            (X_train[top_features], y_train),\n",
        "            (X_valid[top_features], y_valid),\n",
        "        ],\n",
        "        eval_metric=[\"rmse\"],\n",
        "        callbacks=[\n",
        "            early_stopping(stopping_rounds=300),\n",
        "            differential_stopping,\n",
        "        ],\n",
        "    )\n",
        "\n",
        "    # считаем предсказания\n",
        "    preds_train = np.expm1(model.predict(X_train[top_features]))\n",
        "    preds_valid = np.expm1(model.predict(X_valid[top_features]))\n",
        "    preds_full = np.expm1(model.predict(X[top_features]))\n",
        "\n",
        "    # метрики для TRAIN/TEST/FULL\n",
        "    metrics_train = compute_metrics(np.expm1(y_train), preds_train)\n",
        "    metrics_valid = compute_metrics(np.expm1(y_valid), preds_valid)\n",
        "    metrics_full = compute_metrics(np.expm1(Y), preds_full)\n",
        "\n",
        "    # добавляем признак кол-ва фичей\n",
        "    metrics_train[\"dataset\"] = \"TRAIN\"\n",
        "    metrics_valid[\"dataset\"] = \"TEST\"\n",
        "    metrics_full[\"dataset\"] = \"FULL\"\n",
        "    for m in (metrics_train, metrics_valid, metrics_full):\n",
        "        m[\"n_features\"] = k\n",
        "        results.append(m)\n",
        "\n",
        "# теперь добавим метрики для исходной полной модели\n",
        "preds_train = np.expm1(lgbm_model_10_outlined_log.predict(X_train))\n",
        "preds_valid = np.expm1(lgbm_model_10_outlined_log.predict(X_valid))\n",
        "preds_full = np.expm1(lgbm_model_10_outlined_log.predict(X))\n",
        "\n",
        "metrics_train = compute_metrics(np.expm1(y_train), preds_train)\n",
        "metrics_valid = compute_metrics(np.expm1(y_valid), preds_valid)\n",
        "metrics_full = compute_metrics(np.expm1(Y), preds_full)\n",
        "\n",
        "metrics_train[\"dataset\"] = \"TRAIN\"\n",
        "metrics_valid[\"dataset\"] = \"TEST\"\n",
        "metrics_full[\"dataset\"] = \"FULL\"\n",
        "for m in (metrics_train, metrics_valid, metrics_full):\n",
        "    m[\"n_features\"] = X_valid.shape[1]\n",
        "    results.append(m)\n",
        "\n",
        "# собираем в датафрейм\n",
        "df_results = pd.DataFrame(results).set_index([\"n_features\", \"dataset\"])\n",
        "df_results"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "47f801ae",
      "metadata": {},
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "markdown",
      "id": "e085542c",
      "metadata": {},
      "source": [
        "# Попробуем добавить инфу с лагов\n"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "d81d7c9e",
      "metadata": {},
      "source": [
        "## b\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c4f7c3ed",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = pd.read_csv(\"./data/after_eda.csv\")\n",
        "SHUFFLE = True\n",
        "TEST_SIZE = 0.25\n",
        "RANDOM_STATE = 42\n",
        "df.sort_values(\"deal_date\", inplace=True)\n",
        "TARGET = \"price_usd_per_m2\"\n",
        "TARGET_LOG = \"log1p_price_usd_per_m2\""
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d69adcb5",
      "metadata": {},
      "outputs": [],
      "source": [
        "import pandas as pd\n",
        "\n",
        "\n",
        "def create_period_lag_aggregates(\n",
        "    df, target_cols, agg_funcs=None, lags=[1, 2, 3], date_col=\"deal_date\"\n",
        "):\n",
        "    \"\"\"\n",
        "    Создаёт лаговые агрегаты по week, month, quarter\n",
        "    с учётом года (2023Q1, 2023M05, 2023W17)\n",
        "    и правильным хронологическим порядком по deal_date.\n",
        "    \"\"\"\n",
        "    if agg_funcs is None:\n",
        "        agg_funcs = [\"mean\", \"median\", \"min\", \"max\", \"count\"]\n",
        "\n",
        "    df = df.copy()\n",
        "    df[date_col] = pd.to_datetime(df[date_col])\n",
        "\n",
        "    # создаём уникальные периодные идентификаторы\n",
        "    df[\"year\"] = df[date_col].dt.year\n",
        "    df[\"year_quarter\"] = (\n",
        "        df[\"year\"].astype(str) + \"Q\" + df[\"quarter\"].astype(str)\n",
        "    )\n",
        "    df[\"year_month\"] = (\n",
        "        df[\"year\"].astype(str) + \"M\" + df[\"month\"].astype(str).str.zfill(2)\n",
        "    )\n",
        "    df[\"year_week\"] = (\n",
        "        df[\"year\"].astype(str) + \"W\" + df[\"week\"].astype(str).str.zfill(2)\n",
        "    )\n",
        "\n",
        "    # вспомогательный временной индекс\n",
        "    df[\"_time_idx\"] = df[date_col].rank(method=\"first\").astype(int)\n",
        "\n",
        "    period_cols = [\"year_week\", \"year_month\", \"year_quarter\"]\n",
        "\n",
        "    for period_col in period_cols:\n",
        "        for target_col in target_cols:\n",
        "            # агрегируем по периоду\n",
        "            period_stats = (\n",
        "                df.groupby(period_col)\n",
        "                .agg({target_col: agg_funcs, \"_time_idx\": \"min\"})\n",
        "                .reset_index()\n",
        "            )\n",
        "\n",
        "            # расплющиваем мультииндекс колонок\n",
        "            period_stats.columns = [\n",
        "                (\n",
        "                    \"_\".join([c for c in col if c])\n",
        "                    if isinstance(col, tuple)\n",
        "                    else col\n",
        "                )\n",
        "                for col in period_stats.columns\n",
        "            ]\n",
        "\n",
        "            # сортируем по времени\n",
        "            period_stats = period_stats.sort_values(\"_time_idx_min\")\n",
        "\n",
        "            # создаем лаги по временной оси\n",
        "            for func in agg_funcs:\n",
        "                for lag in lags:\n",
        "                    base_col = f\"{target_col}_{func}\"\n",
        "                    lag_name = f\"{target_col}_{period_col}_{func}_lag_{lag}\"\n",
        "                    period_stats[lag_name] = period_stats[base_col].shift(lag)\n",
        "\n",
        "                    # мержим лаги обратно\n",
        "                    df = df.merge(\n",
        "                        period_stats[[period_col, lag_name]],\n",
        "                        on=period_col,\n",
        "                        how=\"left\",\n",
        "                    )\n",
        "\n",
        "    # чистим временные столбцы\n",
        "    df.drop(\n",
        "        columns=[\"_time_idx\", \"year_quarter\", \"year_week\", \"year_month\"],\n",
        "        inplace=True,\n",
        "        errors=\"ignore\",\n",
        "    )\n",
        "\n",
        "    return df"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5b2a701c",
      "metadata": {},
      "outputs": [],
      "source": [
        "def create_categorical_lag_aggregates(\n",
        "    df, cat_cols, windows=[1, 2, 3], date_col=\"deal_date\"\n",
        "):\n",
        "    \"\"\"\n",
        "    Создает агрегированные лаговые фичи для категориальных колонок.\n",
        "    Для категориальных — используем моду (mode) и количество уникальных значений.\n",
        "\n",
        "    Parameters\n",
        "    ----------\n",
        "    df : pd.DataFrame\n",
        "        Исходный датафрейм.\n",
        "    cat_cols : list[str]\n",
        "        Категориальные колонки.\n",
        "    windows : list[int]\n",
        "        Размеры окон.\n",
        "    date_col : str\n",
        "        Колонка с датой.\n",
        "    \"\"\"\n",
        "    df = df.sort_values(by=date_col).copy()\n",
        "\n",
        "    for col in cat_cols:\n",
        "        for w in windows:\n",
        "            rolled = df[col].shift(1).rolling(window=w)\n",
        "            df[f\"{col}_lag_{w}_mode\"] = rolled.apply(\n",
        "                lambda x: x.mode().iloc[0] if not x.mode().empty else None\n",
        "            )\n",
        "            df[f\"{col}_lag_{w}_nunique\"] = rolled.apply(lambda x: x.nunique())\n",
        "\n",
        "    return df"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d9de5e5d",
      "metadata": {},
      "outputs": [],
      "source": [
        "# уберем часть фичей\n",
        "df = df[\n",
        "    [\n",
        "        \"deal_date\",\n",
        "        \"cluster_score\",\n",
        "        \"Name NP\",\n",
        "        \"area_total_m2\",\n",
        "        \"region_name\",\n",
        "        \"floors_above\",\n",
        "        \"cluster\",\n",
        "        \"log1p_areat_total_m2\",\n",
        "        \"category\",\n",
        "        \"ks_area_total_m2\",\n",
        "        \"deal_objects_count\",\n",
        "        \"property_type\",\n",
        "        \"wall_material\",\n",
        "        \"floor\",\n",
        "        \"land_area_m2\",\n",
        "        \"oblast_name\",\n",
        "        \"days_since_min\",\n",
        "        \"sqrt_areat_total_m2\",\n",
        "        \"log1p_ks_area_total_m2\",\n",
        "        \"rub_rate\",\n",
        "        \"usd_rate\",\n",
        "        \"for_clusters_gr\",\n",
        "        \"floors_below\",\n",
        "        \"day\",\n",
        "        \"eur_rate\",\n",
        "        \"dayofyear\",\n",
        "        \"log1p_land_area_m2\",\n",
        "        \"sqrt_ks_area_total_m2\",\n",
        "        \"dow_sin\",\n",
        "        \"week\",\n",
        "        \"dayofweek\",\n",
        "        \"quarter\",\n",
        "        \"month\",\n",
        "        TARGET_LOG,\n",
        "        TARGET,\n",
        "        \"inventory_id\",\n",
        "    ]\n",
        "]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "1786c823",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = create_period_lag_aggregates(\n",
        "    df,\n",
        "    target_cols=[TARGET_LOG],\n",
        "    agg_funcs=[\"mean\", \"median\", \"min\", \"max\", \"count\"],\n",
        "    lags=[1],\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "637ad969",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = df[df[\"log1p_price_usd_per_m2_year_quarter_min_lag_1\"].notna()]\n",
        "df.isna().sum()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "ae0b4fdf",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.drop(columns=[\"inventory_id\", \"deal_date\"], inplace=True, errors=\"ignore\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "061a2f75",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[TARGET].quantile([0.01, 0.05, 0.1, 0.9, 0.95])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "9b3d6174",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(\"Будет изменено\", df[df[TARGET] < 5.96].shape[0])\n",
        "df[TARGET] = np.where(df[TARGET] < 5.96, 5.96, df[TARGET])\n",
        "df[TARGET_LOG] = np.log1p(df[TARGET])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f79329d0",
      "metadata": {},
      "outputs": [],
      "source": [
        "Y = df[TARGET_LOG]\n",
        "X = df.drop(columns=[TARGET, TARGET_LOG])\n",
        "cat_cols = [\n",
        "    \"property_type\",\n",
        "    \"wall_material\",\n",
        "    # \"transferred_share\",\n",
        "    \"category\",\n",
        "    \"for_clusters_gr\",\n",
        "    \"Name NP\",\n",
        "    \"region_name\",\n",
        "    \"oblast_name\",\n",
        "    \"cluster\",\n",
        "]\n",
        "X[cat_cols] = X[cat_cols].astype(\"category\", errors=\"ignore\")\n",
        "\n",
        "cat_idx = [X.columns.get_loc(c) for c in cat_cols]\n",
        "X_train, X_valid, y_train, y_valid = train_test_split(\n",
        "    X, Y, test_size=TEST_SIZE, random_state=RANDOM_STATE, shuffle=SHUFFLE\n",
        ")\n",
        "X_train[cat_cols] = X_train[cat_cols].astype(\"category\")\n",
        "X_valid[cat_cols] = X_valid[cat_cols].astype(\"category\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "2578b670",
      "metadata": {},
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "361c81e9",
      "metadata": {},
      "outputs": [],
      "source": [
        "# теперь попробуем обучить модель на изменненых данных\n",
        "best_params = {\n",
        "    \"boosting_type\": \"gbdt\",\n",
        "    \"colsample_bytree\": 0.6,\n",
        "    \"importance_type\": \"split\",\n",
        "    \"learning_rate\": 0.001,\n",
        "    \"max_depth\": 8,\n",
        "    \"min_child_samples\": 11,\n",
        "    \"min_child_weight\": 4.175410890723387,\n",
        "    \"min_split_gain\": 0.01768422649000459,\n",
        "    \"n_estimators\": 20000,\n",
        "    \"n_jobs\": 0,\n",
        "    \"num_leaves\": 63,\n",
        "    \"objective\": \"regression\",\n",
        "    \"random_state\": 42,\n",
        "    \"reg_alpha\": 2.3326872626500275,\n",
        "    \"reg_lambda\": 2,\n",
        "    \"subsample\": 0.8,\n",
        "    \"max_bin\": 249,\n",
        "    \"extra_trees\": False,\n",
        "    \"verbose\": -1,\n",
        "}\n",
        "\n",
        "lgbm_lag_base = LGBMRegressor(**best_params)\n",
        "differential_stopping = SimpleGapStopping(metric_name=\"rmse\", gap_threshold=1.5)\n",
        "\n",
        "lgbm_lag_base.fit(\n",
        "    X_train,\n",
        "    y_train,\n",
        "    eval_set=[\n",
        "        (X_train, y_train),\n",
        "        (X_valid, y_valid),\n",
        "    ],\n",
        "    eval_metric=[\"rmse\"],\n",
        "    callbacks=[\n",
        "        early_stopping(\n",
        "            stopping_rounds=300,\n",
        "        ),\n",
        "        differential_stopping,\n",
        "        log_evaluation(200),\n",
        "    ],\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b8c937ee",
      "metadata": {},
      "outputs": [],
      "source": [
        "# сначала проверим качество уже обученной модели\n",
        "print(\n",
        "    \"TRAIN\",\n",
        "    compute_metrics(\n",
        "        np.expm1(y_train), np.expm1(lgbm_lag_base.predict(X_train))\n",
        "    ),\n",
        ")\n",
        "print(\n",
        "    \"TEST\",\n",
        "    compute_metrics(\n",
        "        np.expm1(y_valid), np.expm1(lgbm_lag_base.predict(X_valid))\n",
        "    ),\n",
        ")\n",
        "print(\n",
        "    \"FULL\",\n",
        "    compute_metrics(np.expm1(Y), np.expm1(lgbm_lag_base.predict(X))),\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f4881d0e",
      "metadata": {},
      "outputs": [],
      "source": [
        "explainer = shap.Explainer(\n",
        "    lgbm_lag_base, feature_perturbation=\"tree_path_dependent\"\n",
        ")\n",
        "shap_values = explainer(X_valid)\n",
        "shap.summary_plot(shap_values, X_valid, max_display=X_valid.shape[1])"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "b8de7d85",
      "metadata": {},
      "source": [
        "Чисто агрегаты на лагах не дают никакого буста\n"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "1e3e03d1",
      "metadata": {},
      "source": [
        "## C\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8da6991e",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = pd.read_csv(\"./data/after_eda.csv\")\n",
        "SHUFFLE = True\n",
        "TEST_SIZE = 0.25\n",
        "RANDOM_STATE = 42\n",
        "df.sort_values(\"deal_date\", inplace=True)\n",
        "TARGET = \"price_usd_per_m2\"\n",
        "TARGET_LOG = \"log1p_price_usd_per_m2\""
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "7d1b688c",
      "metadata": {},
      "outputs": [],
      "source": [
        "def create_cluster_lag_aggregates_by_value(\n",
        "    df,\n",
        "    cluster_col,\n",
        "    target_col,\n",
        "    agg_funcs=None,\n",
        "    lags=[1, 2, 3],\n",
        "    date_col=\"deal_date\",\n",
        "):\n",
        "    \"\"\"\n",
        "    Создает лаговые агрегаты таргета для каждого уникального значения кластера,\n",
        "    по уникальным периодам (year_week, year_month, year_quarter),\n",
        "    с учетом времени и правильного порядка по deal_date.\n",
        "    \"\"\"\n",
        "    if agg_funcs is None:\n",
        "        agg_funcs = [\"mean\", \"median\", \"min\", \"max\", \"count\"]\n",
        "\n",
        "    df = df.copy()\n",
        "    df[date_col] = pd.to_datetime(df[date_col])\n",
        "\n",
        "    # уникальные периодные идентификаторы\n",
        "    df[\"year\"] = df[date_col].dt.year\n",
        "    df[\"year_week\"] = (\n",
        "        df[\"year\"].astype(str) + \"W\" + df[\"week\"].astype(str).str.zfill(2)\n",
        "    )\n",
        "    df[\"year_month\"] = (\n",
        "        df[\"year\"].astype(str) + \"M\" + df[\"month\"].astype(str).str.zfill(2)\n",
        "    )\n",
        "    df[\"year_quarter\"] = (\n",
        "        df[\"year\"].astype(str) + \"Q\" + df[\"quarter\"].astype(str)\n",
        "    )\n",
        "\n",
        "    # временной индекс для корректной сортировки\n",
        "    df[\"_time_idx\"] = df[date_col].rank(method=\"first\").astype(int)\n",
        "    period_cols = [\"year_month\", \"year_quarter\"]\n",
        "\n",
        "    for period_col in tqdm(period_cols):\n",
        "        # агрегируем по кластеру и периоду\n",
        "        period_stats = (\n",
        "            df.groupby([cluster_col, period_col])\n",
        "            .agg({target_col: agg_funcs, \"_time_idx\": \"min\"})\n",
        "            .reset_index()\n",
        "        )\n",
        "\n",
        "        # расплющиваем мультииндекс колонок\n",
        "        period_stats.columns = [\n",
        "            \"_\".join([c for c in col if c]) if isinstance(col, tuple) else col\n",
        "            for col in period_stats.columns\n",
        "        ]\n",
        "\n",
        "        # сортировка по времени внутри каждого кластера\n",
        "        period_stats = period_stats.sort_values([cluster_col, \"_time_idx_min\"])\n",
        "\n",
        "        # создаем лаги внутри каждого кластера\n",
        "        for func in agg_funcs:\n",
        "            for lag in lags:\n",
        "                base_col = f\"{target_col}_{func}\"\n",
        "                lag_name = (\n",
        "                    f\"{cluster_col}_{target_col}_{period_col}_{func}_lag_{lag}\"\n",
        "                )\n",
        "                period_stats[lag_name] = period_stats.groupby(cluster_col)[\n",
        "                    base_col\n",
        "                ].shift(lag)\n",
        "\n",
        "        # Для каждого уникального значения кластера создаем отдельные колонки\n",
        "        unique_clusters = period_stats[cluster_col].unique()\n",
        "\n",
        "        for cluster_value in unique_clusters:\n",
        "            cluster_stats = period_stats[\n",
        "                period_stats[cluster_col] == cluster_value\n",
        "            ].copy()\n",
        "\n",
        "            for func in agg_funcs:\n",
        "                for lag in lags:\n",
        "                    base_col = f\"{target_col}_{func}\"\n",
        "                    original_lag_name = f\"{cluster_col}_{target_col}_{period_col}_{func}_lag_{lag}\"\n",
        "\n",
        "                    # Создаем уникальное имя колонки для каждого значения кластера\n",
        "                    cluster_specific_lag_name = f\"{cluster_col}_{cluster_value}_{target_col}_{period_col}_{func}_lag_{lag}\"\n",
        "\n",
        "                    # Берем только нужную колонку и переименовываем\n",
        "                    cluster_lag_data = cluster_stats[\n",
        "                        [period_col, original_lag_name]\n",
        "                    ].copy()\n",
        "                    cluster_lag_data.rename(\n",
        "                        columns={original_lag_name: cluster_specific_lag_name},\n",
        "                        inplace=True,\n",
        "                    )\n",
        "\n",
        "                    # Мерджим обратно в основной df\n",
        "                    df = df.merge(cluster_lag_data, on=[period_col], how=\"left\")\n",
        "\n",
        "    # удаляем временные служебные колонки\n",
        "    df.drop(\n",
        "        columns=[\n",
        "            \"_time_idx\",\n",
        "            \"year_week\",\n",
        "            \"year_month\",\n",
        "            \"year_quarter\",\n",
        "            \"year\",\n",
        "        ],\n",
        "        inplace=True,\n",
        "        errors=\"ignore\",\n",
        "    )\n",
        "\n",
        "    return df"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "572aa258",
      "metadata": {},
      "outputs": [],
      "source": [
        "# уберем часть фичей\n",
        "df = df[\n",
        "    [\n",
        "        \"deal_date\",\n",
        "        \"cluster_score\",\n",
        "        \"Name NP\",\n",
        "        \"area_total_m2\",\n",
        "        \"region_name\",\n",
        "        \"floors_above\",\n",
        "        \"cluster\",\n",
        "        \"log1p_areat_total_m2\",\n",
        "        \"category\",\n",
        "        \"ks_area_total_m2\",\n",
        "        \"deal_objects_count\",\n",
        "        \"property_type\",\n",
        "        \"wall_material\",\n",
        "        \"floor\",\n",
        "        \"land_area_m2\",\n",
        "        \"oblast_name\",\n",
        "        \"days_since_min\",\n",
        "        \"sqrt_areat_total_m2\",\n",
        "        \"log1p_ks_area_total_m2\",\n",
        "        \"rub_rate\",\n",
        "        \"usd_rate\",\n",
        "        \"for_clusters_gr\",\n",
        "        \"floors_below\",\n",
        "        \"day\",\n",
        "        \"eur_rate\",\n",
        "        \"dayofyear\",\n",
        "        \"log1p_land_area_m2\",\n",
        "        \"sqrt_ks_area_total_m2\",\n",
        "        \"dow_sin\",\n",
        "        \"week\",\n",
        "        \"dayofweek\",\n",
        "        \"quarter\",\n",
        "        \"month\",\n",
        "        TARGET_LOG,\n",
        "        TARGET,\n",
        "        \"inventory_id\",\n",
        "    ]\n",
        "]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "18b446e9",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.columns"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8bf8bf09",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = create_cluster_lag_aggregates_by_value(\n",
        "    df,\n",
        "    cluster_col=\"category\",\n",
        "    target_col=TARGET_LOG,\n",
        "    agg_funcs=[\"mean\"],\n",
        "    lags=[1],\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c5b249cf",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.isna().sum()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "bd048f40",
      "metadata": {},
      "outputs": [],
      "source": [
        "# df = df[\n",
        "#     df[\"cluster_undef_log1p_price_usd_per_m2_year_quarter_max_lag_1\"].notna()\n",
        "# ]\n",
        "df.isna().sum()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "70c2a64c",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.drop(columns=[\"inventory_id\", \"deal_date\"], inplace=True, errors=\"ignore\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "23d32cdd",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[TARGET].quantile([0.01, 0.05, 0.1, 0.9, 0.95])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "185f575d",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(\"Будет изменено\", df[df[TARGET] < 5.96].shape[0])\n",
        "df[TARGET] = np.where(df[TARGET] < 5.96, 5.96, df[TARGET])\n",
        "df[TARGET_LOG] = np.log1p(df[TARGET])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c5278dfd",
      "metadata": {},
      "outputs": [],
      "source": [
        "Y = df[TARGET_LOG]\n",
        "X = df.drop(columns=[TARGET, TARGET_LOG])\n",
        "cat_cols = [\n",
        "    \"property_type\",\n",
        "    \"wall_material\",\n",
        "    # \"transferred_share\",\n",
        "    \"category\",\n",
        "    \"for_clusters_gr\",\n",
        "    \"Name NP\",\n",
        "    \"region_name\",\n",
        "    \"oblast_name\",\n",
        "    \"cluster\",\n",
        "]\n",
        "X[cat_cols] = X[cat_cols].astype(\"category\", errors=\"ignore\")\n",
        "\n",
        "cat_idx = [X.columns.get_loc(c) for c in cat_cols]\n",
        "X_train, X_valid, y_train, y_valid = train_test_split(\n",
        "    X, Y, test_size=TEST_SIZE, random_state=RANDOM_STATE, shuffle=SHUFFLE\n",
        ")\n",
        "X_train[cat_cols] = X_train[cat_cols].astype(\"category\")\n",
        "X_valid[cat_cols] = X_valid[cat_cols].astype(\"category\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "af6a8bf6",
      "metadata": {},
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d5554e38",
      "metadata": {},
      "outputs": [],
      "source": [
        "# теперь попробуем обучить модель на изменненых данных\n",
        "best_params = {\n",
        "    \"boosting_type\": \"gbdt\",\n",
        "    \"colsample_bytree\": 0.6,\n",
        "    \"importance_type\": \"split\",\n",
        "    \"learning_rate\": 0.001,\n",
        "    \"max_depth\": 8,\n",
        "    \"min_child_samples\": 11,\n",
        "    \"min_child_weight\": 4.175410890723387,\n",
        "    \"min_split_gain\": 0.01768422649000459,\n",
        "    \"n_estimators\": 20000,\n",
        "    \"n_jobs\": 0,\n",
        "    \"num_leaves\": 63,\n",
        "    \"objective\": \"regression\",\n",
        "    \"random_state\": 42,\n",
        "    \"reg_alpha\": 2.3326872626500275,\n",
        "    \"reg_lambda\": 2,\n",
        "    \"subsample\": 0.8,\n",
        "    \"max_bin\": 249,\n",
        "    \"extra_trees\": False,\n",
        "    \"verbose\": -1,\n",
        "}\n",
        "\n",
        "lgbm_lag_base = LGBMRegressor(**best_params)\n",
        "differential_stopping = SimpleGapStopping(metric_name=\"rmse\", gap_threshold=1.5)\n",
        "\n",
        "lgbm_lag_base.fit(\n",
        "    X_train,\n",
        "    y_train,\n",
        "    eval_set=[\n",
        "        (X_train, y_train),\n",
        "        (X_valid, y_valid),\n",
        "    ],\n",
        "    eval_metric=[\"rmse\"],\n",
        "    callbacks=[\n",
        "        early_stopping(\n",
        "            stopping_rounds=300,\n",
        "        ),\n",
        "        differential_stopping,\n",
        "        log_evaluation(200),\n",
        "    ],\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "83f7e514",
      "metadata": {},
      "outputs": [],
      "source": [
        "# сначала проверим качество уже обученной модели\n",
        "print(\n",
        "    \"TRAIN\",\n",
        "    compute_metrics(\n",
        "        np.expm1(y_train), np.expm1(lgbm_lag_base.predict(X_train))\n",
        "    ),\n",
        ")\n",
        "print(\n",
        "    \"TEST\",\n",
        "    compute_metrics(\n",
        "        np.expm1(y_valid), np.expm1(lgbm_lag_base.predict(X_valid))\n",
        "    ),\n",
        ")\n",
        "print(\n",
        "    \"FULL\",\n",
        "    compute_metrics(np.expm1(Y), np.expm1(lgbm_lag_base.predict(X))),\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5b9d2d57",
      "metadata": {},
      "outputs": [],
      "source": [
        "explainer = shap.Explainer(\n",
        "    lgbm_lag_base, feature_perturbation=\"tree_path_dependent\"\n",
        ")\n",
        "shap_values = explainer(X_valid)\n",
        "shap.summary_plot(shap_values, X_valid, max_display=X_valid.shape[1])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "e1301a1f",
      "metadata": {},
      "outputs": [],
      "source": [
        "X_train[cat_cols] = X_train[cat_cols].astype(str).fillna(\"NaN\")\n",
        "X_valid[cat_cols] = X_valid[cat_cols].astype(str).fillna(\"NaN\")\n",
        "train_pool = Pool(X_train, y_train, cat_features=cat_cols)\n",
        "valid_pool = Pool(X_valid, y_valid, cat_features=cat_cols)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f8207906",
      "metadata": {},
      "outputs": [],
      "source": [
        "# теперь попробуем обучить модель на изменненых данных\n",
        "cb = CatBoostRegressor(\n",
        "    learning_rate=8e-3,\n",
        "    n_estimators=4e4,\n",
        ")\n",
        "# differential_stopping = SimpleGapStopping(metric_name=\"rmse\", gap_threshold=1.5)\n",
        "\n",
        "cb.fit(\n",
        "    train_pool,\n",
        "    eval_set=valid_pool,\n",
        "    use_best_model=True,\n",
        "    verbose=200,\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "813618f7",
      "metadata": {},
      "outputs": [],
      "source": [
        "# сначала проверим качество уже обученной модели\n",
        "print(\n",
        "    \"TRAIN\",\n",
        "    compute_metrics(np.expm1(y_train), np.expm1(cb.predict(X_train))),\n",
        ")\n",
        "print(\n",
        "    \"TEST\",\n",
        "    compute_metrics(np.expm1(y_valid), np.expm1(cb.predict(X_valid))),\n",
        ")\n",
        "# print(\n",
        "#     \"FULL\",\n",
        "#     compute_metrics(np.expm1(Y), np.expm1(cb_model_10_outlined_log.predict(X))),\n",
        "# )"
      ]
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.12.7"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}
