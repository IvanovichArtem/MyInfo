{
  "cells": [
    {
      "cell_type": "markdown",
      "id": "8bc7575b",
      "metadata": {},
      "source": [
        "# Imports\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "35f7ef9b",
      "metadata": {},
      "outputs": [],
      "source": [
        "\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "import os\n",
        "from scipy import stats\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "import warnings\n",
        "import re\n",
        "import shap\n",
        "from tqdm import tqdm\n",
        "from lightgbm import early_stopping, log_evaluation\n",
        "import folium\n",
        "pd.set_option(\"display.max_columns\", None)\n",
        "pd.set_option(\"display.max_rows\", 100)\n",
        "\n",
        "sns.set(style=\"whitegrid\")\n",
        "\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "import polars as pl\n",
        "\n",
        "from catboost import CatBoostRegressor, Pool\n",
        "from xgboost import XGBRegressor\n",
        "from lightgbm import LGBMRegressor\n",
        "from sklearn.ensemble import RandomForestRegressor\n",
        "\n",
        "from sklearn.compose import ColumnTransformer\n",
        "from sklearn.preprocessing import (\n",
        "    OneHotEncoder,\n",
        "    PolynomialFeatures,\n",
        "    FunctionTransformer,\n",
        "    StandardScaler,\n",
        ")\n",
        "from sklearn.model_selection import train_test_split\n",
        "from sklearn.metrics import (\n",
        "    mean_squared_error,\n",
        "    mean_absolute_error,\n",
        "    r2_score,\n",
        "    root_mean_squared_error,\n",
        "    mean_absolute_percentage_error,\n",
        ")\n",
        "from sklearn.pipeline import FeatureUnion, Pipeline\n",
        "\n",
        "import pickle\n",
        "\n",
        "warnings.filterwarnings(\"ignore\")"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "ee6bccd8",
      "metadata": {},
      "source": [
        "# Utils\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b0b926a5",
      "metadata": {},
      "outputs": [],
      "source": [
        "from lightgbm.callback import CallbackEnv, EarlyStopException\n",
        "import logging\n",
        "\n",
        "\n",
        "class SimpleGapStopping:\n",
        "    \"\"\"Останавливает обучение сразу при превышении порога разницы\"\"\"\n",
        "\n",
        "    def __init__(self, metric_name=\"rmse\", gap_threshold=3.0, verbose=True):\n",
        "        self.metric_name = metric_name\n",
        "        self.gap_threshold = gap_threshold\n",
        "        self.verbose = verbose\n",
        "        self.order = 20\n",
        "        self.before_iteration = False\n",
        "        self.logger = logging.getLogger(\"LightGBM\")\n",
        "\n",
        "        # Сохраняем предыдущие значения для отслеживания тренда\n",
        "        self.prev_train_metric = None\n",
        "        self.prev_valid_metric = None\n",
        "\n",
        "    def __call__(self, env: CallbackEnv):\n",
        "        if env.evaluation_result_list is None:\n",
        "            return\n",
        "\n",
        "        # Ищем метрики\n",
        "        train_metric, valid_metric = None, None\n",
        "        for result in env.evaluation_result_list:\n",
        "            if len(result) >= 3:\n",
        "                dataset_name, metric_name, metric_value = result[:3]\n",
        "                if metric_name == self.metric_name:\n",
        "                    if \"train\" in dataset_name.lower():\n",
        "                        train_metric = metric_value\n",
        "                    elif \"valid\" in dataset_name.lower():\n",
        "                        valid_metric = metric_value\n",
        "\n",
        "        if train_metric and valid_metric:\n",
        "            gap_ratio = valid_metric / train_metric\n",
        "\n",
        "            # Логируем прогресс каждые 100 итераций\n",
        "            if self.verbose and env.iteration % 100 == 0:\n",
        "                trend = \"\"\n",
        "                if self.prev_train_metric and self.prev_valid_metric:\n",
        "                    train_trend = (\n",
        "                        \"↘\" if train_metric < self.prev_train_metric else \"↗\"\n",
        "                    )\n",
        "                    valid_trend = (\n",
        "                        \"↘\" if valid_metric < self.prev_valid_metric else \"↗\"\n",
        "                    )\n",
        "                    gap_trend = (\n",
        "                        \"↘\"\n",
        "                        if gap_ratio\n",
        "                        < (self.prev_valid_metric / self.prev_train_metric)\n",
        "                        else \"↗\"\n",
        "                    )\n",
        "                    trend = f\" Trend: Train{train_trend} Valid{valid_trend} Gap{gap_trend}\"\n",
        "\n",
        "                print(\n",
        "                    f\"Iter {env.iteration:4d}: {self.metric_name.upper()} - \"\n",
        "                    f\"Train: {train_metric:8.4f}, Valid: {valid_metric:8.4f}, \"\n",
        "                    f\"Gap: {gap_ratio:5.2f}x{trend}\"\n",
        "                )\n",
        "\n",
        "            # Сохраняем текущие значения для следующей итерации\n",
        "            self.prev_train_metric = train_metric\n",
        "            self.prev_valid_metric = valid_metric\n",
        "\n",
        "            # Проверяем условие остановки\n",
        "            if gap_ratio > self.gap_threshold:\n",
        "                if self.verbose:\n",
        "                    print(\n",
        "                        f\"Early stopping triggered at iteration {env.iteration}!\\n\"\n",
        "                        f\"Reason: Gap ratio {gap_ratio:.2f}x exceeds threshold {self.gap_threshold}x\\n\"\n",
        "                        f\"Final metrics - Train {self.metric_name}: {train_metric:.4f}, \"\n",
        "                        f\"Valid {self.metric_name}: {valid_metric:.4f}\"\n",
        "                    )\n",
        "                raise EarlyStopException(\n",
        "                    env.iteration - 1, env.evaluation_result_list\n",
        "                )"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "0fc1b020",
      "metadata": {},
      "outputs": [],
      "source": [
        "def add_date_features(\n",
        "    df: pd.DataFrame,\n",
        "    date_col: str = \"deal_date\",\n",
        "    target_col: str | None = None,\n",
        "    dayfirst: bool = True,\n",
        ") -> pd.DataFrame:\n",
        "    \"\"\"\n",
        "    Добавляет временные фичи + лаговые агрегаты по неделе и месяцу,\n",
        "    добавляя префикс на основе имени столбца с датой.\n",
        "    \"\"\"\n",
        "\n",
        "    out = df.copy()\n",
        "    dt = pd.to_datetime(out[date_col], errors=\"coerce\", dayfirst=dayfirst)\n",
        "\n",
        "    # --- Базовые временные фичи ---\n",
        "    prefix = f\"{date_col}_\"\n",
        "\n",
        "    out[f\"{prefix}year\"] = dt.dt.year\n",
        "    out[f\"{prefix}quarter\"] = dt.dt.quarter\n",
        "    out[f\"{prefix}month\"] = dt.dt.month\n",
        "    out[f\"{prefix}day\"] = dt.dt.day\n",
        "    out[f\"{prefix}dayofweek\"] = dt.dt.dayofweek\n",
        "    out[f\"{prefix}week\"] = dt.dt.isocalendar().week.astype(\"int16\")\n",
        "    out[f\"{prefix}dayofyear\"] = dt.dt.dayofyear\n",
        "\n",
        "    def month_to_season(m):\n",
        "        if m in (12, 1, 2):\n",
        "            return 1\n",
        "        if m in (3, 4, 5):\n",
        "            return 2\n",
        "        if m in (6, 7, 8):\n",
        "            return 3\n",
        "        return 4\n",
        "\n",
        "    out[f\"{prefix}season\"] = (\n",
        "        out[f\"{prefix}month\"].map(month_to_season).astype(\"int8\")\n",
        "    )\n",
        "\n",
        "    origin = dt.min()\n",
        "\n",
        "    # # --- Лаговые агрегаты ---\n",
        "    # if target_col and target_col in out.columns:\n",
        "    #     out = out.sort_values(date_col).reset_index(drop=True)\n",
        "\n",
        "    #     # week lag\n",
        "    #     week_agg = out.groupby(\n",
        "    #         [f\"{prefix}year\", f\"{prefix}week\"], as_index=False\n",
        "    #     )[target_col].agg([\"mean\", \"median\", \"min\", \"max\", \"count\"])\n",
        "    #     week_agg.columns = [f\"{prefix}week_year\", f\"{prefix}week_num\"] + [\n",
        "    #         f\"{target_col}_{date_col}_week_{c}\"\n",
        "    #         for c in [\"mean\", \"median\", \"min\", \"max\", \"count\"]\n",
        "    #     ]\n",
        "    #     week_agg = week_agg.sort_values(\n",
        "    #         [f\"{prefix}week_year\", f\"{prefix}week_num\"]\n",
        "    #     )\n",
        "    #     week_agg[[c for c in week_agg.columns if c.startswith(target_col)]] = (\n",
        "    #         week_agg[\n",
        "    #             [c for c in week_agg.columns if c.startswith(target_col)]\n",
        "    #         ].shift(1)\n",
        "    #     )\n",
        "    #     out = out.merge(\n",
        "    #         week_agg,\n",
        "    #         left_on=[f\"{prefix}year\", f\"{prefix}week\"],\n",
        "    #         right_on=[f\"{prefix}week_year\", f\"{prefix}week_num\"],\n",
        "    #         how=\"left\",\n",
        "    #     )\n",
        "    #     out.drop(\n",
        "    #         [f\"{prefix}week_year\", f\"{prefix}week_num\"], axis=1, inplace=True\n",
        "    #     )\n",
        "\n",
        "    #     # month lag\n",
        "    #     month_agg = out.groupby(\n",
        "    #         [f\"{prefix}year\", f\"{prefix}month\"], as_index=False\n",
        "    #     )[target_col].agg([\"mean\", \"median\", \"min\", \"max\", \"count\"])\n",
        "    #     month_agg.columns = [f\"{prefix}month_year\", f\"{prefix}month_num\"] + [\n",
        "    #         f\"{target_col}_{date_col}_month_{c}\"\n",
        "    #         for c in [\"mean\", \"median\", \"min\", \"max\", \"count\"]\n",
        "    #     ]\n",
        "    #     month_agg = month_agg.sort_values(\n",
        "    #         [f\"{prefix}month_year\", f\"{prefix}month_num\"]\n",
        "    #     )\n",
        "    #     month_agg[\n",
        "    #         [c for c in month_agg.columns if c.startswith(target_col)]\n",
        "    #     ] = month_agg[\n",
        "    #         [c for c in month_agg.columns if c.startswith(target_col)]\n",
        "    #     ].shift(\n",
        "    #         1\n",
        "    #     )\n",
        "    #     out = out.merge(\n",
        "    #         month_agg,\n",
        "    #         left_on=[f\"{prefix}year\", f\"{prefix}month\"],\n",
        "    #         right_on=[f\"{prefix}month_year\", f\"{prefix}month_num\"],\n",
        "    #         how=\"left\",\n",
        "    #     )\n",
        "    #     out.drop(\n",
        "    #         [f\"{prefix}month_year\", f\"{prefix}month_num\"], axis=1, inplace=True\n",
        "    #     )\n",
        "\n",
        "    return out"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d0b6fafb",
      "metadata": {},
      "outputs": [],
      "source": [
        "# ====== Метрики ======\n",
        "def smape_metric(y_true, y_pred, eps=1e-9):\n",
        "    y_true = np.asarray(y_true)\n",
        "    y_pred = np.asarray(y_pred)\n",
        "    denom = np.abs(y_true) + np.abs(y_pred) + eps\n",
        "    return 100.0 * np.mean(2.0 * np.abs(y_pred - y_true) / denom)\n",
        "\n",
        "\n",
        "def mdape_metric(y_true, y_pred, eps=1e-8):\n",
        "    y_true = np.asarray(y_true)\n",
        "    y_pred = np.asarray(y_pred)\n",
        "    denom = np.where(np.abs(y_true) < eps, eps, np.abs(y_true))\n",
        "    ape = np.abs(y_true - y_pred) / denom\n",
        "    return np.median(ape) * 100.0\n",
        "\n",
        "\n",
        "def compute_metrics(y_true_orig, y_pred_orig):\n",
        "    rmse = root_mean_squared_error(y_true_orig, y_pred_orig)\n",
        "    mae = mean_absolute_error(y_true_orig, y_pred_orig)\n",
        "    mse = mean_squared_error(y_true_orig, y_pred_orig)\n",
        "    r2 = r2_score(y_true_orig, y_pred_orig)\n",
        "    mape = 100.0 * mean_absolute_percentage_error(y_true_orig, y_pred_orig)\n",
        "    mdape = mdape_metric(y_true_orig, y_pred_orig)\n",
        "    smape = smape_metric(y_true_orig, y_pred_orig)\n",
        "    return {\n",
        "        \"rmse\": rmse,\n",
        "        \"mse\": mse,\n",
        "        \"mae\": mae,\n",
        "        \"r2\": r2,\n",
        "        \"mape_%\": mape,\n",
        "        \"median_mape_%\": mdape,\n",
        "        \"smape_%\": smape,\n",
        "    }"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "baa7efbe",
      "metadata": {},
      "source": [
        "# Load\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b4af10c4",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = pd.read_csv(\"./data/clean_full_df.csv\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b259f86a",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.columns"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "81c51bab",
      "metadata": {},
      "outputs": [],
      "source": [
        "missing_pct = (\n",
        "    (df.isna().mean()[lambda s: s > 0.5] * 100)\n",
        "    .round(2)\n",
        "    .sort_values(ascending=False)\n",
        ")\n",
        "print((missing_pct.astype(str) + \"%\"))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "cc9204bc",
      "metadata": {},
      "outputs": [],
      "source": [
        "drop_columns = [\n",
        "    \"USD\",  # столбцы из 3 пункта обработки\n",
        "    \"BYN\",\n",
        "    \"EUR\",\n",
        "    \"Форма_BYN\",\n",
        "    \"Форма_EUR\",\n",
        "    \"Форма_USD\",\n",
        "    \"Логика извлечения\",\n",
        "    \"sheet_source\",\n",
        "    \"search_param\",\n",
        "    \"Дата\",\n",
        "    \"rules_5\",\n",
        "    \"rules_6\",\n",
        "    \"п/п\",  # ненужные столбцы (лишний, использовались для заполнения других столбцов)\n",
        "]\n",
        "missing_info_drop_columns = list(df.columns[df.isna().mean() > 0.8])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "2b480ce0",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(df.shape)\n",
        "df.drop(columns=drop_columns, errors=\"ignore\", inplace=True)\n",
        "print(df.shape)\n",
        "df.drop(columns=missing_info_drop_columns, errors=\"ignore\", inplace=True)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "cb568bec",
      "metadata": {},
      "outputs": [],
      "source": [
        "missing_pct = (\n",
        "    (df.isna().mean()[lambda s: s >= 0] * 100)\n",
        "    .round(2)\n",
        "    .sort_values(ascending=False)\n",
        ")\n",
        "print((missing_pct.astype(str) + \"%\"))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f1dd898d",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"Цена в долларах США за кв.м\"] = (\n",
        "    df[\"Цена в долларах США\"] / df[\"Общая площадь, кв.м\"]\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "4e637cfb",
      "metadata": {},
      "outputs": [],
      "source": [
        "# убираем бел рубли и евро, т.к. предсказывать будем цену за кв. м. в долларах сша\n",
        "df.drop(\n",
        "    columns=[\n",
        "        \"Цена в бел. руб.\",\n",
        "        \"Цена в евро\",\n",
        "        \"Цена в долларах США\",\n",
        "        \"Цена в бел. руб. за кв.м\",\n",
        "        \"Цена в евро за кв.м\",\n",
        "        \"Цена по договору\",\n",
        "        \"Валюта по договору\",\n",
        "    ],\n",
        "    inplace=True,\n",
        "    errors=\"ignore\",\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "cf33495d",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.head(2)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c833b42f",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[[\"Дата сделки\", \"Дата ввода\"]]"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "5168502d",
      "metadata": {},
      "source": [
        "## Load GEO\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "fbf05703",
      "metadata": {},
      "outputs": [],
      "source": [
        "import pickle\n",
        "\n",
        "with open(\"./data/GEO.pkl\", \"rb\") as f:\n",
        "    _GEO_CACHE = pickle.load(f)\n",
        "\n",
        "df[\"latitude\"] = None\n",
        "df[\"longitude\"] = None\n",
        "\n",
        "for key, (lat, lon) in tqdm(_GEO_CACHE.items()):\n",
        "    df.loc[df[\"Адрес\"] == key, \"latitude\"] = lat\n",
        "    df.loc[df[\"Адрес\"] == key, \"longitude\"] = lon"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "a6dce4a0",
      "metadata": {},
      "outputs": [],
      "source": [
        "for key, (lat, lon) in _GEO_CACHE.items():\n",
        "    print(key, \"|\", lat, lon)\n",
        "    break"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f1b3b517",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[[\"latitude\", \"longitude\"]].isna().sum()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "2dedd7af",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.drop(\n",
        "    columns=[\n",
        "        \"Описание назначения\",  # много уникальных значений, строки\n",
        "        \"Наименование\",\n",
        "        \"Дата ввода\",\n",
        "        \"Идентификатор сделки\",  # ненужный уникальный идентификатор\n",
        "        # \"Адрес\",  # много уникальных значений, инфа уже передана в другие фичи\n",
        "        \"Описание цены\",  # оттуда уже распарсили инфу\n",
        "        \"Тип цены\",  #  всего 1 уникальное значение\n",
        "        \"Инвентарный номер КС\",  # идентификатор\n",
        "        \"Назначение КС\",\n",
        "        \"Описание назначения КС\",\n",
        "        \"Наименование КС\",\n",
        "        \"Составные элементы и принадлежности\",\n",
        "        \"Кадастровый номер ЗУ\",  # еще один идентификатор\n",
        "        \"Описание назначения ЗУ\",\n",
        "        \"Уникальный номер АТЕ\",  # еще один идентификатор\n",
        "    ],\n",
        "    inplace=True,\n",
        "    errors=\"ignore\",\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d95b3a45",
      "metadata": {},
      "outputs": [],
      "source": [
        "def conv_date(x):\n",
        "    if pd.isna(x):\n",
        "        return pd.NaT\n",
        "    s = str(x).strip()\n",
        "    for fmt in (\"%Y-%m-%d %H:%M:%S\", \"%d.%m.%Y\", \"%Y-%m-%d\"):\n",
        "        try:\n",
        "            return pd.to_datetime(s, format=fmt)\n",
        "        except ValueError:\n",
        "            pass\n",
        "    return pd.NaT"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b291a516",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"Дата сделки\"] = df[\"Дата сделки\"].apply(conv_date)\n",
        "df[\"Дата регистрации договора\"] = df[\"Дата регистрации договора\"].apply(\n",
        "    conv_date\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "71d2af08",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.columns"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "79fd122e",
      "metadata": {},
      "outputs": [],
      "source": [
        "rename_map = {\n",
        "    \"Тип недвижимого имущества\": \"property_type\",\n",
        "    \"Инвентарный номер\": \"inventory_id\",\n",
        "    \"Назначение\": \"purpose\",\n",
        "    \"Общая площадь, кв.м\": \"area_total_m2\",\n",
        "    \"Материал стен\": \"wall_material\",\n",
        "    \"Дата сделки\": \"deal_date\",\n",
        "    \"Дата регистрации договора\": \"contract_reg_date\",\n",
        "    \"Количество объектов в сделке\": \"deal_objects_count\",\n",
        "    \"Цена в долларах США за кв.м\": \"price_usd_per_m2\",\n",
        "    \"Переходящая доля\": \"transferred_share\",\n",
        "    \"Этаж расположения ИП\": \"unit_floor\",\n",
        "    \"Общая площадь КС, кв.м\": \"ks_area_total_m2\",\n",
        "    \"Процент готовности КС\": \"ks_completion_pct\",\n",
        "    \"Количество надземных этажей, шт.\": \"floors_above\",\n",
        "    \"Количество подземных этажей, шт.\": \"floors_below\",\n",
        "    \"Назначение ЗУ\": \"land_use\",\n",
        "    \"Площадь ЗУ, кв.м\": \"land_area_m2\",\n",
        "    \"Маркеры\": \"markers\",\n",
        "    \"Распределение долей до сделки\": \"shares_before\",\n",
        "    \"Распределение долей после сделки\": \"shares_after\",\n",
        "    \"1 Евро (EUR)\": \"eur_rate\",\n",
        "    \"1 Российский рубль (RUB)\": \"rub_rate\",\n",
        "    \"1 Доллар США (USD)\": \"usd_rate\",\n",
        "    \"Name region\": \"region_name\",\n",
        "    \"Name oblast\": \"oblast_name\",\n",
        "}\n",
        "df = df.rename(columns=rename_map)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d1af59b6",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"shares_before\"].value_counts()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "deaf8665",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"shares_before\"].unique()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "64012535",
      "metadata": {},
      "outputs": [],
      "source": [
        "valid_values = [\"{1/1}\", \"{1/1,1/1}\", \"{1/1,1/1,1/1}\"]\n",
        "\n",
        "\n",
        "def sum_is_one(value):\n",
        "    if pd.isna(value):\n",
        "        return True\n",
        "    value = value.strip(\"{}\")\n",
        "    if not value:\n",
        "        return False\n",
        "    try:\n",
        "        fractions = [eval(f) for f in value.split(\",\")]\n",
        "        return abs(sum(fractions) - 1) < 1e-9\n",
        "    except Exception:\n",
        "        return False\n",
        "\n",
        "\n",
        "print(df.shape)\n",
        "# убираем по рекомендации бизнеса\n",
        "df = df[\n",
        "    df[\"shares_before\"].isin(valid_values)\n",
        "    | df[\"shares_before\"].apply(sum_is_one)\n",
        "]\n",
        "print(df.shape)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "cdfd265a",
      "metadata": {},
      "source": [
        "# EDA\n"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "0352564c",
      "metadata": {},
      "source": [
        "## price_usd_per_m2\n",
        "\n",
        "Данный столбец это таргет\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d5d3eeb0",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(df[\"price_usd_per_m2\"].isna().sum())\n",
        "df[\"price_usd_per_m2\"].dropna(inplace=True)\n",
        "\n",
        "print(\"inf values count\", (df[\"price_usd_per_m2\"] == np.inf).sum())\n",
        "display(df[df[\"price_usd_per_m2\"] == np.inf].head())\n",
        "df = df[df[\"price_usd_per_m2\"] != np.inf]\n",
        "df[\"price_usd_per_m2\"] = df[\"price_usd_per_m2\"].round(2)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "dd870799",
      "metadata": {},
      "outputs": [],
      "source": [
        "target_col = \"price_usd_per_m2\""
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "df7d2322",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(f\"=== Таргет: {target_col} ===\")\n",
        "print(f\"Всего наблюдений: {df[target_col].size}\")\n",
        "print(f\"Пропусков: {df[target_col].isna().sum()}\")\n",
        "\n",
        "n_le0 = (df[target_col] <= 0).sum()\n",
        "n_eq0 = (df[target_col] == 0).sum()\n",
        "n_neg = (df[target_col] < 0).sum()\n",
        "print(f\"<= 0: {n_le0} | = 0: {n_eq0} | < 0: {n_neg}\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "a4355dfd",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(df.shape)\n",
        "df[target_col] = np.where(\n",
        "    df[target_col] > df[target_col].quantile(0.1),\n",
        "    df[target_col],\n",
        "    df[target_col].quantile(0.1),\n",
        ")\n",
        "df = df[df[target_col] > 0]\n",
        "print(df.shape)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "85c70079",
      "metadata": {},
      "outputs": [],
      "source": [
        "desc = df[target_col].describe(\n",
        "    percentiles=[0.01, 0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95, 0.99]\n",
        ")\n",
        "display(desc.to_frame(\"value\"))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5977f732",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[df[target_col] > 1800][target_col].sort_values()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "68ea0d5c",
      "metadata": {},
      "outputs": [],
      "source": [
        "skew = stats.skew(df[target_col], bias=False)\n",
        "kurt = stats.kurtosis(df[target_col], fisher=True, bias=False)\n",
        "print(f\"Skewness: {skew:.3f} | Kurtosis(Fisher): {kurt:.3f}\")\n",
        "\n",
        "q1, q3 = np.percentile(df[target_col], [25, 75])\n",
        "iqr = q3 - q1\n",
        "low_whisk = q1 - 1.5 * iqr\n",
        "high_whisk = q3 + 1.5 * iqr\n",
        "print(f\"IQR: {iqr:.3f} | границы: [{low_whisk:.3f}, {high_whisk:.3f}]\")\n",
        "print(\n",
        "    f\"Выбросы ниже: {(df[target_col] < low_whisk).sum()} | выше: {(df[target_col] > high_whisk).sum()}\"\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "11986efb",
      "metadata": {},
      "outputs": [],
      "source": [
        "ax = sns.histplot(df[target_col], bins=100, kde=True)\n",
        "ax.set_title(f\"{target_col}: распределение\")\n",
        "ax.set_xlabel(target_col)\n",
        "ax.set_ylabel(\"count\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "3d68d471",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 3.2))\n",
        "sns.boxplot(x=df[target_col], ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col}: boxplot\")\n",
        "axes[0].set_xlabel(target_col)\n",
        "sns.violinplot(x=df[target_col], ax=axes[1], inner=\"quartile\", cut=0)\n",
        "axes[1].set_title(f\"{target_col}: violin\")\n",
        "axes[1].set_xlabel(target_col)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "4a018d37",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(df.shape, high_whisk, desc[\"1%\"])\n",
        "df = df[~(df[target_col] > high_whisk)]\n",
        "print(\"After delete > high whisk\", df.shape)\n",
        "# df = df[df[target_col] > desc[\"1%\"]]\n",
        "print(df.shape)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "882a7a74",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[target_col].sort_values()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "baeb5e80",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[df[target_col] < 1].shape"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "01ca9e9e",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(14, 5))\n",
        "\n",
        "# Гистограмма до обрезки\n",
        "sns.histplot(df[target_col], bins=100, kde=True, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} до обрезки\")\n",
        "axes[0].set_xlabel(target_col)\n",
        "axes[0].set_ylabel(\"count\")\n",
        "\n",
        "# Гистограмма после обрезки\n",
        "sns.histplot(\n",
        "    df[~(df[target_col] > high_whisk)][target_col],\n",
        "    bins=100,\n",
        "    kde=True,\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"{target_col} после обрезки\")\n",
        "axes[1].set_xlabel(target_col)\n",
        "axes[1].set_ylabel(\"count\")\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "65459831",
      "metadata": {},
      "outputs": [],
      "source": [
        "ax = sns.histplot(df[target_col], bins=100, kde=True)\n",
        "ax.set_title(f\"{target_col}: распределение\")\n",
        "ax.set_xlabel(target_col)\n",
        "ax.set_ylabel(\"count\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "84401000",
      "metadata": {},
      "outputs": [],
      "source": [
        "s_log = np.log1p(df[target_col])\n",
        "ax = sns.histplot(s_log, bins=60, kde=True)\n",
        "ax.set_title(f\"log1p({target_col}): распределение\")\n",
        "ax.set_xlabel(f\"log1p({target_col})\")\n",
        "ax.set_ylabel(\"count\")\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "\n",
        "skew_log = stats.skew(s_log, bias=False)\n",
        "kurt_log = stats.kurtosis(s_log, fisher=True, bias=False)\n",
        "print(f\"После log1p -> Skew: {skew_log:.3f} | Kurtosis: {kurt_log:.3f}\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "ccce5cdd",
      "metadata": {},
      "outputs": [],
      "source": [
        "log_target_col = f\"log1p_{target_col}\"\n",
        "df[log_target_col] = df[target_col].apply(np.log1p)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "8168b090",
      "metadata": {},
      "source": [
        "Сильный правый хвост, попробуем обучить с лог-шкалой и без, а потом проверим метрики\n"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c1",
      "metadata": {},
      "source": [
        "## property_type\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5a705bc8",
      "metadata": {},
      "outputs": [],
      "source": [
        "sns.countplot(data=df, x=\"property_type\")\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "3b18a935",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4), sharey=False)\n",
        "sns.boxplot(data=df, x=\"property_type\", y=target_col, ax=axes[0])\n",
        "axes[0].set_title(\"target_col by property_type\")\n",
        "\n",
        "sns.boxplot(data=df, x=\"property_type\", y=log_target_col, ax=axes[1])\n",
        "axes[1].set_title(\"log_target_col by property_type\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d9efd836",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.violinplot(data=df, x=\"property_type\", y=target_col, cut=0, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by property_type\")\n",
        "\n",
        "sns.violinplot(data=df, x=\"property_type\", y=log_target_col, cut=0, ax=axes[1])\n",
        "axes[1].set_title(f\"{log_target_col} by property_type\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "cc311fed",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.histplot(\n",
        "    data=df,\n",
        "    x=target_col,\n",
        "    hue=\"property_type\",\n",
        "    bins=50,\n",
        "    element=\"step\",\n",
        "    stat=\"density\",\n",
        "    common_norm=False,\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"{target_col} | hist by property_type\")\n",
        "\n",
        "sns.histplot(\n",
        "    data=df,\n",
        "    x=log_target_col,\n",
        "    hue=\"property_type\",\n",
        "    bins=50,\n",
        "    element=\"step\",\n",
        "    stat=\"density\",\n",
        "    common_norm=False,\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} | hist by property_type\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c3",
      "metadata": {},
      "source": [
        "## purpose\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "880a5d4d",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"purpose\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "62bf8592",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.drop(columns=[\"purpose\"], inplace=True)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c4",
      "metadata": {},
      "source": [
        "## area_total_m2\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "bbedf00b",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"area_total_m2\"].sort_values()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "41d45ada",
      "metadata": {},
      "outputs": [],
      "source": [
        "sns.histplot(data=df, x=\"area_total_m2\", bins=50)\n",
        "plt.title(\"Distribution of area_total_m2\")\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5c61f591",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.scatterplot(data=df, x=\"area_total_m2\", y=target_col, ax=axes[0], alpha=0.5)\n",
        "axes[0].set_title(f\"{target_col} vs area_total_m2\")\n",
        "\n",
        "sns.scatterplot(\n",
        "    data=df, x=\"area_total_m2\", y=log_target_col, ax=axes[1], alpha=0.5\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} vs area_total_m2\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "df431b9a",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.regplot(\n",
        "    data=df,\n",
        "    x=\"area_total_m2\",\n",
        "    y=target_col,\n",
        "    ax=axes[0],\n",
        "    scatter_kws={\"alpha\": 0.4},\n",
        ")\n",
        "axes[0].set_title(f\"Linear trend: {target_col} ~ area_total_m2\")\n",
        "\n",
        "sns.regplot(\n",
        "    data=df,\n",
        "    x=\"area_total_m2\",\n",
        "    y=log_target_col,\n",
        "    ax=axes[1],\n",
        "    scatter_kws={\"alpha\": 0.4},\n",
        ")\n",
        "axes[1].set_title(f\"Linear trend: {log_target_col} ~ area_total_m2\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "80c4297f",
      "metadata": {},
      "outputs": [],
      "source": [
        "corr_target = df[[\"area_total_m2\", target_col]].corr().iloc[0, 1]\n",
        "corr_log = df[[\"area_total_m2\", log_target_col]].corr().iloc[0, 1]\n",
        "print(\"corr(area_total_m2, target_col)   =\", corr_target)\n",
        "print(\"corr(area_total_m2, log_target_col) =\", corr_log)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "0882c08c",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"area_total_m2_bin\"] = pd.qcut(df[\"area_total_m2\"], q=10, duplicates=\"drop\")\n",
        "fig, axes = plt.subplots(1, 2, figsize=(14, 4))\n",
        "sns.boxplot(data=df, x=\"area_total_m2_bin\", y=target_col, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by area_total_m2 deciles\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=45)\n",
        "\n",
        "sns.boxplot(data=df, x=\"area_total_m2_bin\", y=log_target_col, ax=axes[1])\n",
        "axes[1].set_title(f\"{log_target_col} by area_total_m2 deciles\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=45)\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "df.drop(columns=\"area_total_m2_bin\", inplace=True)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5783981f",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"log1p_areat_total_m2\"] = df[\"area_total_m2\"].apply(np.log1p)\n",
        "df[\"exp_areat_total_m2\"] = df[\"area_total_m2\"].apply(np.exp)\n",
        "df[\"sqrt_areat_total_m2\"] = df[\"area_total_m2\"].apply(np.sqrt)\n",
        "sc = StandardScaler()\n",
        "df[\"area_total_m2\"] = sc.fit_transform(df[[\"area_total_m2\"]])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8343c186",
      "metadata": {},
      "outputs": [],
      "source": [
        "sns.histplot(df[\"log1p_areat_total_m2\"])"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c5",
      "metadata": {},
      "source": [
        "## wall_material\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "e40bb79a",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"wall_material\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "99deeefc",
      "metadata": {},
      "outputs": [],
      "source": [
        "rules = [\n",
        "    (\"кирпич\", r\"кирпич\"),\n",
        "    (\"блок\", r\"блок\"),\n",
        "    (\"железобет\", r\"железобет|сборн.*железобет|ж/б\"),\n",
        "    (\"бетон\", r\"\\bбетон\\b|монолит\"),\n",
        "    (\"дерево\", r\"дерев|брус|бревн|доск\"),\n",
        "    (\"камень\", r\"кам(ень|ни)|природн\"),\n",
        "    (\"металл\", r\"металл\"),\n",
        "    (\"панель\", r\"панел\"),\n",
        "    (\"стекло\", r\"стекл\"),\n",
        "    (\"смешан\", r\"смешан|комбинир|каркас\"),\n",
        "    (\"прочее\", r\"друго|иное|не определ\"),\n",
        "]\n",
        "\n",
        "cats = pd.Series(df[\"wall_material\"].dropna().unique()).astype(str)\n",
        "\n",
        "\n",
        "def _key(s):\n",
        "    t = s.lower()\n",
        "    for i, (_, pat) in enumerate(rules):\n",
        "        if re.search(pat, t):\n",
        "            return (i, t)\n",
        "    return (len(rules), t)  # всё, что не совпало — в конец, по алфавиту\n",
        "\n",
        "\n",
        "order = sorted(cats, key=_key)\n",
        "order, len(order)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "22431809",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(20, 10))\n",
        "sns.boxplot(data=df, y=\"wall_material\", x=target_col, ax=axes[0], order=order)\n",
        "axes[0].set_title(f\"{target_col} by wall_material\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=30)\n",
        "\n",
        "sns.boxplot(\n",
        "    data=df, y=\"wall_material\", x=log_target_col, ax=axes[1], order=order\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} by wall_material\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=30)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "68c9134f",
      "metadata": {},
      "source": [
        "Лучше объединить общие категори в одну (кирпичи в кирпичи и тд)\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d2559acd",
      "metadata": {},
      "outputs": [],
      "source": [
        "EXACT_MAP = {\n",
        "    \"Кирпич\": \"Кирпич\",\n",
        "    \"Кирпич толщиной кладки до 45 см\": \"Кирпич\",\n",
        "    \"Кирпич толщиной кладки более 51 см\": \"Кирпич\",\n",
        "    \"Блоки стеновые\": \"Блоки\",\n",
        "    \"Блоки легкобетонные (силикатные, шлакобетонные, газосиликатные и др.)\": \"Блоки (легкие)\",\n",
        "    \"Блоки бетонные\": \"Блоки\",\n",
        "    \"Крупноблочные из керамзитовых блоков и др.\": \"Блоки (легкие)\",\n",
        "    \"Блоки, камни, кирпичи\": \"Блоки\",\n",
        "    \"Железобетонные изделия\": \"Железобетон\",\n",
        "    \"Железобетон монолитный\": \"Железобетон\",\n",
        "    \"Колонны, диафрагмы жесткости, сборный железобетон\": \"Железобетон\",\n",
        "    \"Каркас ж/б с кирпичным заполнением\": \"Железобетон\",\n",
        "    \"Бетон монолитный\": \"Бетон\",\n",
        "    \"Бетон\": \"Бетон\",\n",
        "    \"Легкий бетон (шлакобетон, аглопоритобетон, опилкобетон и др.)\": \"Бетон (легкий)\",\n",
        "    \"Крупнопанельные\": \"Панели\",\n",
        "    \"Сэндвич-панели\": \"Панели\",\n",
        "    \"Панельные гофрированные (металл с утеплителем)\": \"Панели\",\n",
        "    \"Металл\": \"Металл\",\n",
        "    \"Древесина\": \"Деревянные\",\n",
        "    \"Дерево, бруски, бревна\": \"Деревянные\",\n",
        "    \"Брус\": \"Деревянные\",\n",
        "    \"Бревно\": \"Деревянные\",\n",
        "    \"Доски\": \"Деревянные\",\n",
        "    \"Изделия из древесины\": \"Деревянные\",\n",
        "    \"Камень керамический (мягкие и твердые породы)\": \"Камень\",\n",
        "    \"Камень природный\": \"Камень\",\n",
        "    \"Стекло\": \"Стекло\",\n",
        "    \"Смешанной конструкции\": \"Смешанные/каркасные\",\n",
        "    \"Каркасно-засыпные\": \"Смешанные/каркасные\",\n",
        "    \"Материал стен не определен\": \"Не определено\",\n",
        "    \"Иное\": \"Другое/Иное\",\n",
        "    \"Другое\": \"Другое/Иное\",\n",
        "}\n",
        "\n",
        "\n",
        "def to_clean_category(x):\n",
        "    # сначала пробуем точную мапу, иначе — общая нормализация\n",
        "    return EXACT_MAP.get(str(x).strip())"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "bf6b62a5",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"wall_material\"] = df[\"wall_material\"].apply(to_clean_category)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "429979ea",
      "metadata": {},
      "outputs": [],
      "source": [
        "sns.countplot(data=df, y=\"wall_material\")\n",
        "plt.title(\"wall_material_new | class counts\")\n",
        "plt.xticks(rotation=30)\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "4a12b824",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(18, 7))\n",
        "sns.boxplot(data=df, x=\"wall_material\", y=target_col, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by wall_material\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=30)\n",
        "\n",
        "sns.boxplot(data=df, x=\"wall_material\", y=log_target_col, ax=axes[1])\n",
        "axes[1].set_title(f\"{log_target_col} by wall_material\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=30)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "eb60d4b0",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"wall_material\"].fillna(df[\"wall_material\"].mode()[0], inplace=True)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c6",
      "metadata": {},
      "source": [
        "## deal_date\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "992e2701",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = add_date_features(\n",
        "    df,\n",
        "    \"deal_date\",\n",
        "    target_col,\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f3cf48f7",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"deal_date\"].describe()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "deb5219a",
      "metadata": {},
      "outputs": [],
      "source": [
        "ts = (\n",
        "    df.dropna(subset=[\"deal_date\"])\n",
        "    .assign(cnt=1)\n",
        "    .set_index(\"deal_date\")[\"cnt\"]\n",
        "    .resample(\"MS\")\n",
        "    .sum()\n",
        "    .reset_index()\n",
        "    .rename(columns={\"deal_date\": \"period\", \"cnt\": \"count\"})\n",
        ")\n",
        "\n",
        "plt.figure(figsize=(8, 3))\n",
        "sns.lineplot(data=ts, x=\"period\", y=\"count\", marker=\"o\")\n",
        "plt.title(\"Сделки по месяцам\")\n",
        "plt.xlabel(\"Месяц\")\n",
        "plt.ylabel(\"Количество\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d0415cd0",
      "metadata": {},
      "outputs": [],
      "source": [
        "plt.figure(figsize=(8, 3))\n",
        "sns.histplot(df[\"deal_date\"].dropna().dt.date, bins=100)\n",
        "plt.title(\"Распределение сделок по дням\")\n",
        "plt.xlabel(\"Дата\")\n",
        "plt.ylabel(\"Количество\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "71df36ea",
      "metadata": {},
      "outputs": [],
      "source": [
        "ts_mean = (\n",
        "    df.dropna(subset=[\"deal_date\"])\n",
        "    .set_index(\"deal_date\")\n",
        "    .resample(\"MS\")[[target_col, log_target_col]]\n",
        "    .mean()\n",
        "    .reset_index()\n",
        "    .rename(columns={\"deal_date\": \"period\"})\n",
        ")\n",
        "\n",
        "fig, axes = plt.subplots(1, 2, figsize=(14, 3.5), sharex=True)\n",
        "sns.lineplot(data=ts_mean, x=\"period\", y=target_col, marker=\"o\", ax=axes[0])\n",
        "axes[0].set_title(f\"Среднее {target_col} по месяцам\")\n",
        "sns.lineplot(data=ts_mean, x=\"period\", y=log_target_col, marker=\"o\", ax=axes[1])\n",
        "axes[1].set_title(f\"Среднее {log_target_col} по месяцам\")\n",
        "for ax in axes:\n",
        "    ax.set_xlabel(\"Месяц\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "0da86e78",
      "metadata": {},
      "source": [
        "Видно, что инфы до 2020 года, очень мало\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "6db08f25",
      "metadata": {},
      "outputs": [],
      "source": [
        "by_dow = df[\"deal_date_dayofweek\"].value_counts().sort_index().reset_index()\n",
        "by_dow.columns = [\"dayofweek\", \"count\"]\n",
        "\n",
        "plt.figure(figsize=(6, 3))\n",
        "sns.barplot(data=by_dow, x=\"dayofweek\", y=\"count\")\n",
        "plt.title(\"Распределение по дням недели\")\n",
        "plt.xlabel(\"День недели (0=Пн … 6=Вс)\")\n",
        "plt.ylabel(\"Количество\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d67b7d05",
      "metadata": {},
      "outputs": [],
      "source": [
        "by_dow_val = df.dropna(subset=[\"deal_date_dayofweek\"])[\n",
        "    [\"deal_date_dayofweek\", target_col, log_target_col]\n",
        "].melt(id_vars=\"deal_date_dayofweek\", var_name=\"which\", value_name=\"val\")\n",
        "\n",
        "fig, axes = plt.subplots(1, 2, figsize=(12, 3.5), sharey=False)\n",
        "sns.barplot(\n",
        "    data=by_dow_val.query(\"which == @target_col\"),\n",
        "    x=\"deal_date_dayofweek\",\n",
        "    y=\"val\",\n",
        "    estimator=\"mean\",\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"Mean {target_col} по дням недели\")\n",
        "sns.barplot(\n",
        "    data=by_dow_val.query(\"which == @log_target_col\"),\n",
        "    x=\"deal_date_dayofweek\",\n",
        "    y=\"val\",\n",
        "    estimator=\"mean\",\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"Mean {log_target_col} по дням недели\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "521535df",
      "metadata": {},
      "outputs": [],
      "source": [
        "by_month = df[\"deal_date_month\"].value_counts().sort_index().reset_index()\n",
        "by_month.columns = [\"month\", \"count\"]\n",
        "\n",
        "plt.figure(figsize=(6, 3))\n",
        "sns.barplot(data=by_month, x=\"month\", y=\"count\")\n",
        "plt.title(\"Распределение по месяцам\")\n",
        "plt.xlabel(\"Месяц\")\n",
        "plt.ylabel(\"Количество\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "35a12c29",
      "metadata": {},
      "outputs": [],
      "source": [
        "by_month_val = df.dropna(subset=[\"deal_date_month\"])[\n",
        "    [\"deal_date_month\", target_col, log_target_col]\n",
        "].melt(id_vars=\"deal_date_month\", var_name=\"which\", value_name=\"val\")\n",
        "\n",
        "fig, axes = plt.subplots(1, 2, figsize=(12, 3.5), sharex=True)\n",
        "sns.barplot(\n",
        "    data=by_month_val.query(\"which == @target_col\"),\n",
        "    x=\"deal_date_month\",\n",
        "    y=\"val\",\n",
        "    estimator=\"mean\",\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"Mean {target_col} по месяцам\")\n",
        "sns.barplot(\n",
        "    data=by_month_val.query(\"which == @log_target_col\"),\n",
        "    x=\"deal_date_month\",\n",
        "    y=\"val\",\n",
        "    estimator=\"mean\",\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"Mean {log_target_col} по месяцам\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "973cdf52",
      "metadata": {},
      "outputs": [],
      "source": [
        "by_q = df[\"deal_date_quarter\"].value_counts().sort_index().reset_index()\n",
        "by_q.columns = [\"quarter\", \"count\"]\n",
        "\n",
        "plt.figure(figsize=(5, 3))\n",
        "sns.barplot(data=by_q, x=\"quarter\", y=\"count\")\n",
        "plt.title(\"Распределение по кварталам\")\n",
        "plt.xlabel(\"Квартал\")\n",
        "plt.ylabel(\"Количество\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "51d05582",
      "metadata": {},
      "outputs": [],
      "source": [
        "by_q_val = df.dropna(subset=[\"deal_date_quarter\"])[\n",
        "    [\"deal_date_quarter\", target_col, log_target_col]\n",
        "].melt(id_vars=\"deal_date_quarter\", var_name=\"which\", value_name=\"val\")\n",
        "\n",
        "fig, axes = plt.subplots(1, 2, figsize=(10, 3.5))\n",
        "sns.barplot(\n",
        "    data=by_q_val.query(\"which == @target_col\"),\n",
        "    x=\"deal_date_quarter\",\n",
        "    y=\"val\",\n",
        "    estimator=\"mean\",\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"Mean {target_col} по кварталам\")\n",
        "sns.barplot(\n",
        "    data=by_q_val.query(\"which == @log_target_col\"),\n",
        "    x=\"deal_date_quarter\",\n",
        "    y=\"val\",\n",
        "    estimator=\"mean\",\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"Mean {log_target_col} по кварталам\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b070f28b",
      "metadata": {},
      "outputs": [],
      "source": [
        "pivot = (\n",
        "    df.pivot_table(\n",
        "        index=\"deal_date_dayofweek\",\n",
        "        columns=\"deal_date_month\",\n",
        "        values=\"deal_date\",\n",
        "        aggfunc=\"count\",\n",
        "    )\n",
        "    .fillna(0)\n",
        "    .reindex(index=[0, 1, 2, 3, 4, 5, 6], columns=range(1, 13))\n",
        ")\n",
        "\n",
        "plt.figure(figsize=(7, 3.6))\n",
        "ax = sns.heatmap(\n",
        "    pivot, annot=True, fmt=\".0f\", cbar=True, linewidths=0.5, linecolor=\"white\"\n",
        ")\n",
        "ax.set_title(\"Интенсивность: день недели × месяц\")\n",
        "ax.set_xlabel(\"Месяц\")\n",
        "ax.set_ylabel(\"День недели (0=Пн … 6=Вс)\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "84af861f",
      "metadata": {},
      "outputs": [],
      "source": [
        "pivot_t = df.pivot_table(\n",
        "    index=\"deal_date_dayofweek\",\n",
        "    columns=\"deal_date_month\",\n",
        "    values=target_col,\n",
        "    aggfunc=\"mean\",\n",
        ").reindex(index=[0, 1, 2, 3, 4, 5, 6], columns=range(1, 13))\n",
        "pivot_l = df.pivot_table(\n",
        "    index=\"deal_date_dayofweek\",\n",
        "    columns=\"deal_date_month\",\n",
        "    values=log_target_col,\n",
        "    aggfunc=\"mean\",\n",
        ").reindex(index=[0, 1, 2, 3, 4, 5, 6], columns=range(1, 13))\n",
        "\n",
        "fig, axes = plt.subplots(1, 2, figsize=(14, 4))\n",
        "sns.heatmap(\n",
        "    pivot_t,\n",
        "    annot=False,\n",
        "    cbar=True,\n",
        "    linewidths=0.4,\n",
        "    linecolor=\"white\",\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"Mean {target_col}: dow × month\")\n",
        "axes[0].set_xlabel(\"Месяц\")\n",
        "axes[0].set_ylabel(\"День недели\")\n",
        "sns.heatmap(\n",
        "    pivot_l,\n",
        "    annot=False,\n",
        "    cbar=True,\n",
        "    linewidths=0.4,\n",
        "    linecolor=\"white\",\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"Mean {log_target_col}: dow × month\")\n",
        "axes[1].set_xlabel(\"Месяц\")\n",
        "axes[1].set_ylabel(\"День недели\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "96b0b99f",
      "metadata": {},
      "outputs": [],
      "source": [
        "try:\n",
        "    fig, axes = plt.subplots(1, 2, figsize=(14, 3.5), sharex=True)\n",
        "    sns.regplot(\n",
        "        data=df,\n",
        "        x=\"deal_date_days_since_min\",\n",
        "        y=target_col,\n",
        "        scatter_kws={\"alpha\": 0.3, \"s\": 15},\n",
        "        ax=axes[0],\n",
        "    )\n",
        "    axes[0].set_title(f\"{target_col} ~ days_since_min\")\n",
        "    axes[0].set_xlabel(\"Дней с минимальной даты\")\n",
        "    sns.regplot(\n",
        "        data=df,\n",
        "        x=\"deal_date_days_since_min\",\n",
        "        y=log_target_col,\n",
        "        scatter_kws={\"alpha\": 0.3, \"s\": 15},\n",
        "        ax=axes[1],\n",
        "    )\n",
        "    axes[1].set_title(f\"{log_target_col} ~ days_since_min\")\n",
        "    axes[1].set_xlabel(\"Дней с минимальной даты\")\n",
        "    plt.tight_layout()\n",
        "    plt.show()\n",
        "except Exception:\n",
        "    print(\"Not found\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "339261ae",
      "metadata": {},
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "2b2cfde6",
      "metadata": {},
      "outputs": [],
      "source": [
        "# # дропнем там где нету инфы по лагу\n",
        "# df = df[df[\"price_usd_per_m2_month_count\"].notna()]\n",
        "# display(df.isna().sum())"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c7",
      "metadata": {},
      "source": [
        "## contract_reg_date\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "65a50f64",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"contract_reg_date\"].isna().sum()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "e1119f3a",
      "metadata": {},
      "outputs": [],
      "source": [
        "ts = (\n",
        "    df.dropna(subset=[\"contract_reg_date\"])\n",
        "    .assign(cnt=1)\n",
        "    .set_index(\"contract_reg_date\")[\"cnt\"]\n",
        "    .resample(\"MS\")\n",
        "    .sum()\n",
        "    .reset_index()\n",
        "    .rename(columns={\"contract_reg_date\": \"period\", \"cnt\": \"count\"})\n",
        ")\n",
        "\n",
        "plt.figure(figsize=(8, 3))\n",
        "sns.lineplot(data=ts, x=\"period\", y=\"count\", marker=\"o\")\n",
        "plt.title(\"contract_reg_date по месяцам\")\n",
        "plt.xlabel(\"Месяц\")\n",
        "plt.ylabel(\"Количество\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "4ec34f85",
      "metadata": {},
      "outputs": [],
      "source": [
        "plt.figure(figsize=(8, 3))\n",
        "sns.histplot(df[\"contract_reg_date\"].dropna().dt.date, bins=30)\n",
        "plt.title(\"Распределение contract_reg_date по дням\")\n",
        "plt.xlabel(\"Дата\")\n",
        "plt.ylabel(\"Количество\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "06a0c4a2",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"contract_reg_date\"].isna().mean()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "bb96bf78",
      "metadata": {},
      "outputs": [],
      "source": [
        "# df = add_date_features(df, \"contract_reg_date\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d00697b9",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = df.drop(columns=[\"contract_reg_date\"])"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c8",
      "metadata": {},
      "source": [
        "## deal_objects_count\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "49d060bc",
      "metadata": {},
      "outputs": [],
      "source": [
        "vc = (\n",
        "    df[\"deal_objects_count\"]\n",
        "    .value_counts(dropna=True)\n",
        "    .sort_values(ascending=False)\n",
        "    .reset_index()\n",
        ")\n",
        "vc.columns = [\"deal_objects_count\", \"count\"]\n",
        "\n",
        "plt.figure(figsize=(10, 4))\n",
        "sns.barplot(data=vc.head(30), x=\"deal_objects_count\", y=\"count\")\n",
        "plt.title(\"Топ-30 значений deal_objects_count по частоте\")\n",
        "plt.xticks(rotation=45)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "df539a83",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(14, 4))\n",
        "sns.regplot(\n",
        "    data=df,\n",
        "    x=\"deal_objects_count\",\n",
        "    y=target_col,\n",
        "    scatter_kws={\"alpha\": 0.35, \"s\": 15},\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"{target_col} ~ deal_objects_count\")\n",
        "\n",
        "sns.regplot(\n",
        "    data=df,\n",
        "    x=\"deal_objects_count\",\n",
        "    y=log_target_col,\n",
        "    scatter_kws={\"alpha\": 0.35, \"s\": 15},\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} ~ deal_objects_count\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8056caf9",
      "metadata": {},
      "outputs": [],
      "source": [
        "top_vals = vc.head(15)[\"deal_objects_count\"].tolist()\n",
        "\n",
        "fig, axes = plt.subplots(1, 2, figsize=(14, 4), sharex=True)\n",
        "sns.barplot(\n",
        "    data=df[df[\"deal_objects_count\"].isin(top_vals)],\n",
        "    x=\"deal_objects_count\",\n",
        "    y=target_col,\n",
        "    estimator=\"mean\",\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"Mean {target_col} для топ-15 deal_objects_count\")\n",
        "sns.barplot(\n",
        "    data=df[df[\"deal_objects_count\"].isin(top_vals)],\n",
        "    x=\"deal_objects_count\",\n",
        "    y=log_target_col,\n",
        "    estimator=\"mean\",\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"Mean {log_target_col} для топ-15 deal_objects_count\")\n",
        "for ax in axes:\n",
        "    ax.set_xlabel(\"deal_objects_count\")\n",
        "    ax.tick_params(axis=\"x\", rotation=45)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c10",
      "metadata": {},
      "source": [
        "## transferred_share\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "da95141b",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"transferred_share\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "37c2a7ba",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"transferred_share\"].fillna(\"NaN\", inplace=True)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "9d6fbf4f",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(18, 7))\n",
        "sns.boxplot(data=df, x=\"transferred_share\", y=target_col, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by transferred_share\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=30)\n",
        "\n",
        "sns.boxplot(data=df, x=\"transferred_share\", y=log_target_col, ax=axes[1])\n",
        "axes[1].set_title(f\"{log_target_col} by transferred_share\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=30)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c11",
      "metadata": {},
      "source": [
        "## unit_floor\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f4d13fae",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"unit_floor\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f192dab6",
      "metadata": {},
      "outputs": [],
      "source": [
        "# уже есть переменная floor\n",
        "df.drop(columns=[\"unit_floor\"], inplace=True)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c12",
      "metadata": {},
      "source": [
        "## ks_area_total_m2\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "2c8d0dfd",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[[\"area_total_m2\", \"ks_area_total_m2\"]]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "6c28b56f",
      "metadata": {},
      "outputs": [],
      "source": [
        "sns.histplot(data=df, x=\"ks_area_total_m2\", bins=60)\n",
        "plt.title(\"Distribution of ks_area_total_m2\")\n",
        "plt.xlabel(\"ks_area_total_m2\")\n",
        "plt.ylabel(\"count\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "cf895546",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.scatterplot(\n",
        "    data=df, x=\"ks_area_total_m2\", y=target_col, alpha=0.5, ax=axes[0]\n",
        ")\n",
        "axes[0].set_title(f\"{target_col} vs ks_area_total_m2\")\n",
        "\n",
        "sns.scatterplot(\n",
        "    data=df, x=\"ks_area_total_m2\", y=log_target_col, alpha=0.5, ax=axes[1]\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} vs ks_area_total_m2\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "19865a84",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.regplot(\n",
        "    data=df,\n",
        "    x=\"ks_area_total_m2\",\n",
        "    y=target_col,\n",
        "    scatter_kws={\"alpha\": 0.35, \"s\": 15},\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"Linear trend: {target_col} ~ ks_area_total_m2\")\n",
        "\n",
        "sns.regplot(\n",
        "    data=df,\n",
        "    x=\"ks_area_total_m2\",\n",
        "    y=log_target_col,\n",
        "    scatter_kws={\"alpha\": 0.35, \"s\": 15},\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"Linear trend: {log_target_col} ~ ks_area_total_m2\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "9d2e9305",
      "metadata": {},
      "outputs": [],
      "source": [
        "corr_area = df[[\"ks_area_total_m2\", \"area_total_m2\"]].corr().iloc[0, 1]\n",
        "print(\"Correlation between ares features\", corr_area)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "be040023",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"_ks_area_bin\"] = pd.qcut(df[\"ks_area_total_m2\"], q=10, duplicates=\"drop\")\n",
        "\n",
        "fig, axes = plt.subplots(1, 2, figsize=(14, 4))\n",
        "sns.boxplot(data=df, x=\"_ks_area_bin\", y=target_col, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by ks_area_total_m2 deciles\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=45)\n",
        "\n",
        "sns.boxplot(data=df, x=\"_ks_area_bin\", y=log_target_col, ax=axes[1])\n",
        "axes[1].set_title(f\"{log_target_col} by ks_area_total_m2 deciles\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=45)\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "\n",
        "df.drop(columns=\"_ks_area_bin\", inplace=True)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "948f35a1",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.scatterplot(\n",
        "    data=df, x=\"ks_area_total_m2\", y=target_col, alpha=0.4, ax=axes[0]\n",
        ")\n",
        "axes[0].set_xscale(\"log\")\n",
        "axes[0].set_title(f\"{target_col} vs ks_area_total_m2 (log X)\")\n",
        "\n",
        "sns.scatterplot(\n",
        "    data=df, x=\"ks_area_total_m2\", y=log_target_col, alpha=0.4, ax=axes[1]\n",
        ")\n",
        "axes[1].set_xscale(\"log\")\n",
        "axes[1].set_title(f\"{log_target_col} vs ks_area_total_m2 (log X)\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8a257321",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(df[\"ks_area_total_m2\"].median())\n",
        "df[\"ks_area_total_m2\"].fillna(df[\"ks_area_total_m2\"].median(), inplace=True)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5c9efee9",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"log1p_ks_area_total_m2\"] = df[\"ks_area_total_m2\"].apply(np.log1p)\n",
        "df[\"sqrt_ks_area_total_m2\"] = df[\"ks_area_total_m2\"].apply(np.sqrt)\n",
        "sc = StandardScaler()\n",
        "df[\"ks_area_total_m2\"] = sc.fit_transform(df[[\"ks_area_total_m2\"]])"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c13",
      "metadata": {},
      "source": [
        "## ks_completion_pct\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "7775451d",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"ks_completion_pct\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c8543b6a",
      "metadata": {},
      "source": [
        "Заменим фичу на булево\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "48c16d04",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"ks_completion_bool\"] = df[\"ks_completion_pct\"].apply(\n",
        "    lambda x: 1 if x == 100 else 0\n",
        ")\n",
        "df[\"ks_completion_bool\"].value_counts()\n",
        "df = df.drop(columns=[\"ks_completion_pct\"])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "2523317d",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(10, 4))\n",
        "sns.boxplot(\n",
        "    data=df, x=\"ks_completion_bool\", y=target_col, order=[0, 1], ax=axes[0]\n",
        ")\n",
        "axes[0].set_title(f\"{target_col} by ks_completion_bool\")\n",
        "\n",
        "sns.boxplot(\n",
        "    data=df, x=\"ks_completion_bool\", y=log_target_col, order=[0, 1], ax=axes[1]\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} by ks_completion_bool\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "fa3292cc",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(10, 4))\n",
        "sns.violinplot(\n",
        "    data=df,\n",
        "    x=\"ks_completion_bool\",\n",
        "    y=target_col,\n",
        "    cut=0,\n",
        "    order=[0, 1],\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"{target_col} by ks_completion_bool\")\n",
        "\n",
        "sns.violinplot(\n",
        "    data=df,\n",
        "    x=\"ks_completion_bool\",\n",
        "    y=log_target_col,\n",
        "    cut=0,\n",
        "    order=[0, 1],\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} by ks_completion_bool\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8ac65138",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.histplot(\n",
        "    data=df,\n",
        "    x=target_col,\n",
        "    hue=\"ks_completion_bool\",\n",
        "    bins=50,\n",
        "    element=\"step\",\n",
        "    stat=\"density\",\n",
        "    common_norm=False,\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"{target_col}: hist by ks_completion_bool\")\n",
        "\n",
        "sns.histplot(\n",
        "    data=df,\n",
        "    x=log_target_col,\n",
        "    hue=\"ks_completion_bool\",\n",
        "    bins=50,\n",
        "    element=\"step\",\n",
        "    stat=\"density\",\n",
        "    common_norm=False,\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col}: hist by ks_completion_bool\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c14",
      "metadata": {},
      "source": [
        "## floors_above\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "1f095650",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"floors_above\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "eaad33cd",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(18, 7))\n",
        "sns.boxplot(data=df, x=\"floors_above\", y=target_col, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by floors_above\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=30)\n",
        "\n",
        "sns.boxplot(data=df, x=\"floors_above\", y=log_target_col, ax=axes[1])\n",
        "axes[1].set_title(f\"{log_target_col} by floors_above\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=30)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c15",
      "metadata": {},
      "source": [
        "## floors_below\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f92895c8",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"floors_below\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "2e3fedac",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(18, 7))\n",
        "sns.boxplot(data=df, x=\"floors_below\", y=target_col, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by floors_below\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=30)\n",
        "\n",
        "sns.boxplot(data=df, x=\"floors_below\", y=log_target_col, ax=axes[1])\n",
        "axes[1].set_title(f\"{log_target_col} by floors_below\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=30)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c16",
      "metadata": {},
      "source": [
        "## land_use\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "255e6fd3",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"land_use\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "4d80bc7f",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = df.drop(columns=[\"land_use\"])"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c17",
      "metadata": {},
      "source": [
        "## land_area_m2\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "464ae9ab",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(df[\"land_area_m2\"].isna().sum())"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "36e35ee6",
      "metadata": {},
      "outputs": [],
      "source": [
        "sns.histplot(data=df, x=\"land_area_m2\", bins=60)\n",
        "plt.title(\"Distribution of land_area_m2\")\n",
        "plt.xlabel(\"land_area_m2\")\n",
        "plt.ylabel(\"count\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "29d634e9",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.scatterplot(data=df, x=\"land_area_m2\", y=target_col, alpha=0.5, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} vs land_area_m2\")\n",
        "\n",
        "sns.scatterplot(\n",
        "    data=df, x=\"land_area_m2\", y=log_target_col, alpha=0.5, ax=axes[1]\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} vs land_area_m2\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "aad2e821",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.regplot(\n",
        "    data=df,\n",
        "    x=\"land_area_m2\",\n",
        "    y=target_col,\n",
        "    scatter_kws={\"alpha\": 0.35, \"s\": 15},\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"Linear trend: {target_col} ~ land_area_m2\")\n",
        "\n",
        "sns.regplot(\n",
        "    data=df,\n",
        "    x=\"land_area_m2\",\n",
        "    y=log_target_col,\n",
        "    scatter_kws={\"alpha\": 0.35, \"s\": 15},\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"Linear trend: {log_target_col} ~ land_area_m2\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "caa49110",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.scatterplot(data=df, x=\"land_area_m2\", y=target_col, alpha=0.4, ax=axes[0])\n",
        "axes[0].set_xscale(\"log\")\n",
        "axes[0].set_title(f\"{target_col} vs land_area_m2 (log X)\")\n",
        "\n",
        "sns.scatterplot(\n",
        "    data=df, x=\"land_area_m2\", y=log_target_col, alpha=0.4, ax=axes[1]\n",
        ")\n",
        "axes[1].set_xscale(\"log\")\n",
        "axes[1].set_title(f\"{log_target_col} vs land_area_m2 (log X)\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "80fa0338",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(df[\"land_area_m2\"].median())\n",
        "df[\"land_area_m2\"].fillna(df[\"land_area_m2\"].median(), inplace=True)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "0325223e",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"log1p_land_area_m2\"] = df[\"land_area_m2\"].apply(np.log1p)\n",
        "df[\"sqrt_land_area_m2\"] = df[\"land_area_m2\"].apply(np.sqrt)\n",
        "sc = StandardScaler()\n",
        "df[\"land_area_m2\"] = sc.fit_transform(df[[\"land_area_m2\"]])"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c18",
      "metadata": {},
      "source": [
        "## markers\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "950e1c7e",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"markers\"].value_counts()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8e12ce12",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = df.drop(columns=[\"markers\"])"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c19",
      "metadata": {},
      "source": [
        "## shares_before\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "4c185480",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"shares_before\"].value_counts()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "0a4f804b",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = df.drop(columns=[\"shares_before\"])"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c20",
      "metadata": {},
      "source": [
        "## shares_after\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "82634219",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"shares_after\"].value_counts()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "e0b7fd7a",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = df.drop(columns=[\"shares_after\"])"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c21",
      "metadata": {
        "notebookRunGroups": {
          "groupValue": "1"
        }
      },
      "source": [
        "## eur_rate\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "e95f5e33",
      "metadata": {
        "notebookRunGroups": {
          "groupValue": "2"
        }
      },
      "outputs": [],
      "source": [
        "print(df[\"eur_rate\"].isna().sum())\n",
        "print(df[\"usd_rate\"].isna().sum())\n",
        "print(df[\"rub_rate\"].isna().sum())"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "954f510d",
      "metadata": {},
      "outputs": [],
      "source": [
        "date_key = df[\"deal_date\"].dt.normalize()\n",
        "\n",
        "daily_known = (\n",
        "    df.loc[df[\"eur_rate\"].notna()]\n",
        "    .groupby(date_key[df[\"eur_rate\"].notna()])[\"eur_rate\"]\n",
        "    .first()\n",
        ")\n",
        "df[\"eur_rate\"] = df[\"eur_rate\"].fillna(date_key.map(daily_known))\n",
        "\n",
        "daily_known = (\n",
        "    df.loc[df[\"usd_rate\"].notna()]\n",
        "    .groupby(date_key[df[\"usd_rate\"].notna()])[\"usd_rate\"]\n",
        "    .first()\n",
        ")\n",
        "df[\"usd_rate\"] = df[\"usd_rate\"].fillna(date_key.map(daily_known))\n",
        "\n",
        "daily_known = (\n",
        "    df.loc[df[\"rub_rate\"].notna()]\n",
        "    .groupby(date_key[df[\"rub_rate\"].notna()])[\"rub_rate\"]\n",
        "    .first()\n",
        ")\n",
        "df[\"rub_rate\"] = df[\"rub_rate\"].fillna(date_key.map(daily_known))"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "dacd171c",
      "metadata": {},
      "source": [
        "Есть пропуски ~40 для всех курсов, интерполируем значения с помощью `deal_date`\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "e8275ca1",
      "metadata": {},
      "outputs": [],
      "source": [
        "ts_eur = (\n",
        "    df.dropna(subset=[\"deal_date\", \"eur_rate\"])\n",
        "    .set_index(\"deal_date\")[\"eur_rate\"]\n",
        "    .resample(\"MS\")\n",
        "    .mean()\n",
        "    .reset_index()\n",
        ")\n",
        "\n",
        "plt.figure(figsize=(10, 3.5))\n",
        "sns.lineplot(data=ts_eur, x=\"deal_date\", y=\"eur_rate\", marker=\"o\")\n",
        "plt.title(\"eur_rate по месяцам\")\n",
        "plt.xlabel(\"Месяц\")\n",
        "plt.ylabel(\"eur_rate\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c22",
      "metadata": {},
      "source": [
        "## rub_rate\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "6321dc1f",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = df[df[\"rub_rate\"].notna()]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "21564923",
      "metadata": {},
      "outputs": [],
      "source": [
        "ts_eur = (\n",
        "    df.dropna(subset=[\"deal_date\", \"rub_rate\"])\n",
        "    .set_index(\"deal_date\")[\"rub_rate\"]\n",
        "    .resample(\"MS\")\n",
        "    .mean()\n",
        "    .reset_index()\n",
        ")\n",
        "\n",
        "plt.figure(figsize=(10, 3.5))\n",
        "sns.lineplot(data=ts_eur, x=\"deal_date\", y=\"rub_rate\", marker=\"o\")\n",
        "plt.title(\"rub_rate по месяцам\")\n",
        "plt.xlabel(\"Месяц\")\n",
        "plt.ylabel(\"rub_rate\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c23",
      "metadata": {},
      "source": [
        "## usd_rate\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b1c92fef",
      "metadata": {},
      "outputs": [],
      "source": [
        "ts_eur = (\n",
        "    df.dropna(subset=[\"deal_date\", \"usd_rate\"])\n",
        "    .set_index(\"deal_date\")[\"usd_rate\"]\n",
        "    .resample(\"MS\")\n",
        "    .mean()\n",
        "    .reset_index()\n",
        ")\n",
        "\n",
        "plt.figure(figsize=(10, 3.5))\n",
        "sns.lineplot(data=ts_eur, x=\"deal_date\", y=\"usd_rate\", marker=\"o\")\n",
        "plt.title(\"usd_rate по месяцам\")\n",
        "plt.xlabel(\"Месяц\")\n",
        "plt.ylabel(\"usd_rate\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c24",
      "metadata": {},
      "source": [
        "## floor\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8ee084a6",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"floor\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c51c4f0d",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(18, 7))\n",
        "sns.boxplot(data=df, x=\"floor\", y=target_col, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by floor\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=30)\n",
        "\n",
        "sns.boxplot(data=df, x=\"floor\", y=log_target_col, ax=axes[1])\n",
        "axes[1].set_title(f\"{log_target_col} by floor\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=30)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c25",
      "metadata": {},
      "source": [
        "## category\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "9a2004d5",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"category\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "795feb47",
      "metadata": {},
      "outputs": [],
      "source": [
        "order_freq = df[\"category\"].value_counts().index.tolist()\n",
        "\n",
        "plt.figure(figsize=(10, 4))\n",
        "sns.countplot(data=df, x=\"category\", order=order_freq)\n",
        "plt.title(\"category | class counts\")\n",
        "plt.xticks(rotation=45, ha=\"right\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "a5650c82",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(14, 5))\n",
        "sns.boxplot(data=df, x=\"category\", y=target_col, order=order_freq, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by category\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=45)\n",
        "\n",
        "sns.boxplot(\n",
        "    data=df, x=\"category\", y=log_target_col, order=order_freq, ax=axes[1]\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} by category\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=45)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "24cb463a",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(14, 5))\n",
        "sns.violinplot(\n",
        "    data=df, x=\"category\", y=target_col, cut=0, order=order_freq, ax=axes[0]\n",
        ")\n",
        "axes[0].set_title(f\"{target_col} by category\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=45)\n",
        "\n",
        "sns.violinplot(\n",
        "    data=df, x=\"category\", y=log_target_col, cut=0, order=order_freq, ax=axes[1]\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} by category\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=45)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "4e345814",
      "metadata": {},
      "outputs": [],
      "source": [
        "sns.displot(\n",
        "    data=df,\n",
        "    x=log_target_col,\n",
        "    hue=\"category\",\n",
        "    kind=\"hist\",\n",
        "    bins=50,\n",
        "    element=\"step\",\n",
        "    stat=\"density\",\n",
        ")\n",
        "plt.suptitle(f\"Hist {log_target_col} by category\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "7a3b6402",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"category\"].fillna(\"undef\", inplace=True)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c26",
      "metadata": {},
      "source": [
        "## for_clusters_gr\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "0613eec6",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"for_clusters_gr\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "6cca7bb2",
      "metadata": {},
      "outputs": [],
      "source": [
        "order = df[\"for_clusters_gr\"].value_counts().index.tolist()\n",
        "\n",
        "# распределение классов\n",
        "plt.figure(figsize=(6, 3))\n",
        "sns.countplot(data=df, x=\"for_clusters_gr\", order=order)\n",
        "plt.title(\"for_clusters_gr | class counts\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "7971de98",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.boxplot(data=df, x=\"for_clusters_gr\", y=target_col, order=order, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by for_clusters_gr\")\n",
        "\n",
        "sns.boxplot(\n",
        "    data=df, x=\"for_clusters_gr\", y=log_target_col, order=order, ax=axes[1]\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} by for_clusters_gr\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "7e6f852c",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.violinplot(\n",
        "    data=df, x=\"for_clusters_gr\", y=target_col, cut=0, order=order, ax=axes[0]\n",
        ")\n",
        "axes[0].set_title(f\"{target_col} by for_clusters_gr\")\n",
        "\n",
        "sns.violinplot(\n",
        "    data=df,\n",
        "    x=\"for_clusters_gr\",\n",
        "    y=log_target_col,\n",
        "    cut=0,\n",
        "    order=order,\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col} by for_clusters_gr\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "cd093ffb",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.histplot(\n",
        "    data=df,\n",
        "    x=target_col,\n",
        "    hue=\"for_clusters_gr\",\n",
        "    bins=50,\n",
        "    element=\"step\",\n",
        "    stat=\"density\",\n",
        "    common_norm=False,\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"{target_col}: hist by for_clusters_gr\")\n",
        "\n",
        "sns.histplot(\n",
        "    data=df,\n",
        "    x=log_target_col,\n",
        "    hue=\"for_clusters_gr\",\n",
        "    bins=50,\n",
        "    element=\"step\",\n",
        "    stat=\"density\",\n",
        "    common_norm=False,\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col}: hist by for_clusters_gr\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c27",
      "metadata": {},
      "source": [
        "## Name NP\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "0899f78f",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(df[\"Name NP\"].isna().sum())\n",
        "df[\"Name NP\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c28",
      "metadata": {},
      "source": [
        "## region_name\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8dc917a2",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(df[\"region_name\"].isna().sum())\n",
        "df[\"region_name\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c29",
      "metadata": {},
      "source": [
        "## oblast_name\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "1337105b",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"oblast_name\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "60d10d6c",
      "metadata": {},
      "outputs": [],
      "source": [
        "plt.figure(figsize=(7, 3))\n",
        "sns.countplot(data=df, x=\"oblast_name\")\n",
        "plt.title(\"oblast_name | counts\")\n",
        "plt.xticks(rotation=30)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d7bf3a93",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
        "sns.boxplot(data=df, x=\"oblast_name\", y=target_col, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by oblast_name\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=30)\n",
        "\n",
        "sns.boxplot(data=df, x=\"oblast_name\", y=log_target_col, ax=axes[1])\n",
        "axes[1].set_title(f\"{log_target_col} by oblast_name\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=30)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "14471661",
      "metadata": {},
      "outputs": [],
      "source": [
        "g1 = sns.displot(\n",
        "    data=df,\n",
        "    x=target_col,\n",
        "    col=\"oblast_name\",\n",
        "    col_wrap=4,\n",
        "    bins=40,\n",
        "    element=\"step\",\n",
        "    stat=\"density\",\n",
        ")\n",
        "g1.fig.subplots_adjust(top=0.9)\n",
        "g1.fig.suptitle(f\"Hist {target_col} by oblast_name\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "9ab4b9d2",
      "metadata": {},
      "outputs": [],
      "source": [
        "g2 = sns.displot(\n",
        "    data=df,\n",
        "    x=log_target_col,\n",
        "    col=\"oblast_name\",\n",
        "    col_wrap=4,\n",
        "    bins=40,\n",
        "    element=\"step\",\n",
        "    stat=\"density\",\n",
        ")\n",
        "g2.fig.subplots_adjust(top=0.9)\n",
        "g2.fig.suptitle(f\"Hist {log_target_col} by oblast_name\")"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c30",
      "metadata": {},
      "source": [
        "## cluster_score\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "69ee253d",
      "metadata": {},
      "outputs": [],
      "source": [
        "df[\"_cs_is_neg\"] = (df[\"cluster_score\"] == -1).astype(\"int8\")\n",
        "df[\"_cs_pos\"] = df[\"cluster_score\"].where(\n",
        "    df[\"cluster_score\"] >= 0\n",
        ")  # только валидные (>=0)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "110a05f1",
      "metadata": {},
      "outputs": [],
      "source": [
        "plt.figure(figsize=(6, 3))\n",
        "sns.countplot(x=df[\"_cs_is_neg\"].map({0: \">=0\", 1: \"-1 (neg)\"}))\n",
        "plt.title(\"cluster_score: доля -1 vs >=0\")\n",
        "plt.xlabel(\"\")\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "\n",
        "plt.figure(figsize=(8, 3))\n",
        "sns.histplot(df[\"_cs_pos\"].dropna(), bins=60)\n",
        "plt.title(\"cluster_score (>=0), full scale\")\n",
        "plt.xlabel(\"cluster_score\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "67015a6a",
      "metadata": {},
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "4c7ccad3",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(10, 4))\n",
        "sns.boxplot(data=df, x=\"_cs_is_neg\", y=target_col, ax=axes[0])\n",
        "axes[0].set_xticklabels([\">=0\", \"-1 (neg)\"])\n",
        "axes[0].set_title(f\"{target_col} by cluster_score group\")\n",
        "\n",
        "sns.boxplot(data=df, x=\"_cs_is_neg\", y=log_target_col, ax=axes[1])\n",
        "axes[1].set_xticklabels([\">=0\", \"-1 (neg)\"])\n",
        "axes[1].set_title(f\"{log_target_col} by cluster_score group\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "6ed44faa",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.drop(columns=[\"_cs_pos\"], inplace=True)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c31",
      "metadata": {},
      "source": [
        "## cluster\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "3b00324e",
      "metadata": {},
      "outputs": [],
      "source": [
        "plt.figure(figsize=(8, 3))\n",
        "sns.countplot(data=df, x=\"cluster\")\n",
        "plt.title(\"cluster | counts\")\n",
        "plt.xticks(rotation=30)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c678d98c",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(14, 4))\n",
        "sns.boxplot(data=df, x=\"cluster\", y=target_col, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by cluster\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=30)\n",
        "\n",
        "sns.boxplot(data=df, x=\"cluster\", y=log_target_col, ax=axes[1])\n",
        "axes[1].set_title(f\"{log_target_col} by cluster\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=30)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "593d0a27",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(14, 4))\n",
        "sns.violinplot(data=df, x=\"cluster\", y=target_col, cut=0, ax=axes[0])\n",
        "axes[0].set_title(f\"{target_col} by cluster\")\n",
        "axes[0].tick_params(axis=\"x\", rotation=30)\n",
        "\n",
        "sns.violinplot(data=df, x=\"cluster\", y=log_target_col, cut=0, ax=axes[1])\n",
        "axes[1].set_title(f\"{log_target_col} by cluster\")\n",
        "axes[1].tick_params(axis=\"x\", rotation=30)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d54cb8e3",
      "metadata": {},
      "outputs": [],
      "source": [
        "fig, axes = plt.subplots(1, 2, figsize=(14, 4))\n",
        "sns.histplot(\n",
        "    data=df,\n",
        "    x=target_col,\n",
        "    hue=\"cluster\",\n",
        "    bins=50,\n",
        "    element=\"step\",\n",
        "    stat=\"density\",\n",
        "    common_norm=False,\n",
        "    ax=axes[0],\n",
        ")\n",
        "axes[0].set_title(f\"{target_col}: hist by cluster\")\n",
        "\n",
        "sns.histplot(\n",
        "    data=df,\n",
        "    x=log_target_col,\n",
        "    hue=\"cluster\",\n",
        "    bins=50,\n",
        "    element=\"step\",\n",
        "    stat=\"density\",\n",
        "    common_norm=False,\n",
        "    ax=axes[1],\n",
        ")\n",
        "axes[1].set_title(f\"{log_target_col}: hist by cluster\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "e7fe4bef",
      "metadata": {},
      "source": [
        "## GEO\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "839fe3ae",
      "metadata": {},
      "outputs": [],
      "source": [
        "import folium\n",
        "from folium.plugins import MarkerCluster\n",
        "import branca.colormap as cm\n",
        "\n",
        "# Отбираем только строки с координатами\n",
        "df_plot = df.dropna(subset=[\"latitude\", \"longitude\"])\n",
        "\n",
        "# Создаём карту\n",
        "m = folium.Map(\n",
        "    location=[df_plot[\"latitude\"].mean(), df_plot[\"longitude\"].mean()],\n",
        "    zoom_start=10,\n",
        ")\n",
        "\n",
        "# Кластеризация точек\n",
        "marker_cluster = MarkerCluster().add_to(m)\n",
        "\n",
        "# Создаём градиентную цветовую карту\n",
        "colormap = cm.LinearColormap(\n",
        "    colors=[\"blue\", \"green\", \"yellow\", \"red\"],\n",
        "    vmin=df_plot[target_col].min(),\n",
        "    vmax=df_plot[target_col].max(),\n",
        "    caption=\"Target Value\",\n",
        ")\n",
        "\n",
        "# Добавляем точки на карту с градиентной окраской\n",
        "for _, row in df_plot.iterrows():\n",
        "    folium.CircleMarker(\n",
        "        location=[row[\"latitude\"], row[\"longitude\"]],\n",
        "        radius=5,\n",
        "        color=colormap(row[target_col]),\n",
        "        fill=True,\n",
        "        fill_color=colormap(row[target_col]),\n",
        "        fill_opacity=0.7,\n",
        "        popup=f\"{target_col}: {row[target_col]} {row['Адрес']}\",\n",
        "    ).add_to(marker_cluster)\n",
        "\n",
        "# Добавляем легенду градиента\n",
        "colormap.add_to(m)\n",
        "\n",
        "# Отображаем карту в Jupyter\n",
        "m"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c380b1b1",
      "metadata": {},
      "outputs": [],
      "source": [
        "# import plotly.express as px\n",
        "\n",
        "# # Ваши данные\n",
        "# df_plot = df.dropna(subset=[\"latitude\", \"longitude\", target_col])\n",
        "\n",
        "# # Создание карты\n",
        "# fig = px.scatter_mapbox(\n",
        "#     df_plot,\n",
        "#     lat=\"latitude\",\n",
        "#     lon=\"longitude\",\n",
        "#     size=target_col,\n",
        "#     color=target_col,\n",
        "#     color_continuous_scale=\"Viridis\",\n",
        "#     size_max=15,\n",
        "#     zoom=10,\n",
        "#     mapbox_style=\"open-street-map\",\n",
        "#     hover_name=target_col,\n",
        "# )\n",
        "\n",
        "# fig.update_layout(\n",
        "#     title=\"Визуализация данных на карте\",\n",
        "#     margin={\"r\": 0, \"t\": 50, \"l\": 0, \"b\": 0},\n",
        "#     width=1600,\n",
        "#     height=1400,\n",
        "# )\n",
        "\n",
        "# # fig.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "1d8ae063",
      "metadata": {},
      "outputs": [],
      "source": [
        "import geopandas as gpd\n",
        "import pandas as pd\n",
        "from shapely.geometry import Point\n",
        "\n",
        "# Преобразуем df в GeoDataFrame\n",
        "geometry = [Point(xy) for xy in zip(df[\"longitude\"], df[\"latitude\"])]\n",
        "gdf = gpd.GeoDataFrame(df, geometry=geometry, crs=\"EPSG:4326\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "6a93287f",
      "metadata": {},
      "outputs": [],
      "source": [
        "gdf[\"Name NP\"].value_counts(dropna=False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b742d6fc",
      "metadata": {},
      "outputs": [],
      "source": [
        "# center_minsk = [53.902334, 27.561879]\n",
        "# m = folium.Map(location=center_minsk, zoom_start=11, tiles=\"CartoDB positron\")\n",
        "\n",
        "# # Цвета для кластеров\n",
        "# colors = [\"red\", \"blue\", \"green\", \"purple\", \"orange\", \"brown\", \"pink\", \"gray\"]\n",
        "\n",
        "# for _, row in gdf.dropna(\n",
        "#     subset=[\"latitude\", \"longitude\", \"minsk_geo_cluster\"]\n",
        "# ).iterrows():\n",
        "#     color = colors[int(row[\"minsk_geo_cluster\"]) % len(colors)]\n",
        "#     folium.CircleMarker(\n",
        "#         location=[row[\"latitude\"], row[\"longitude\"]],\n",
        "#         radius=4,\n",
        "#         color=color,\n",
        "#         fill=True,\n",
        "#         fill_opacity=0.6,\n",
        "#     ).add_to(m)\n",
        "\n",
        "# # Добавим легенду\n",
        "# legend_html = (\n",
        "#     \"\"\"\n",
        "# <div style=\"\n",
        "#     position: fixed;\n",
        "#     bottom: 50px; left: 50px; width: 160px; height: auto;\n",
        "#     border:2px solid grey; z-index:9999; font-size:14px;\n",
        "#     background-color:white; padding: 10px;\">\n",
        "# <b>Кластеры</b><br>\n",
        "# \"\"\"\n",
        "#     + \"\".join(\n",
        "#         f'<i style=\"background:{c};width:12px;height:12px;float:left;margin-right:8px\"></i>'\n",
        "#         f\"Кластер {i}<br>\"\n",
        "#         for i, c in enumerate(colors)\n",
        "#     )\n",
        "#     + \"</div>\"\n",
        "# )\n",
        "\n",
        "# m.get_root().html.add_child(folium.Element(legend_html))\n",
        "\n",
        "# # Если вы в Jupyter\n",
        "# m"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "cfbc72a0",
      "metadata": {},
      "outputs": [],
      "source": [
        "# gdf.groupby(\"minsk_geo_cluster\")[\"price_usd_per_m2\"].agg(\n",
        "#     [\"mean\", \"median\", \"min\", \"max\"]\n",
        "# )"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "54e13b9e",
      "metadata": {},
      "source": [
        "обычный kmeans разделил географически, но Минск не разделился на сегменат по ценам\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b394f03b",
      "metadata": {},
      "outputs": [],
      "source": [
        "from sklearn.cluster import KMeans\n",
        "from sklearn.preprocessing import StandardScaler\n",
        "\n",
        "features = gdf.loc[\n",
        "    gdf[\"Name NP\"] == \"минск\", [\"latitude\", \"longitude\", \"price_usd_per_m2\"]\n",
        "].dropna()\n",
        "scaler = StandardScaler()\n",
        "scaled = scaler.fit_transform(features)\n",
        "\n",
        "kmeans = KMeans(n_clusters=2, random_state=42, n_init=10)\n",
        "kmeans.fit(scaled)\n",
        "\n",
        "gdf.loc[features.index, \"minsk_geo_cluster_price\"] = kmeans.labels_"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "2c84d533",
      "metadata": {},
      "outputs": [],
      "source": [
        "center_minsk = [53.902334, 27.561879]\n",
        "m = folium.Map(location=center_minsk, zoom_start=11, tiles=\"CartoDB positron\")\n",
        "\n",
        "# Цвета для кластеров\n",
        "colors = [\"red\", \"blue\", \"green\", \"purple\", \"orange\", \"brown\", \"pink\", \"gray\"]\n",
        "\n",
        "stats = (\n",
        "    gdf.groupby(\"minsk_geo_cluster_price\")[\"price_usd_per_m2\"]\n",
        "    .agg([\"count\", \"mean\", 'median', \"min\", \"max\", \"std\"])\n",
        "    .sort_values(\n",
        "        \"minsk_geo_cluster_price\",\n",
        "    )\n",
        ")\n",
        "display(stats)\n",
        "\n",
        "for _, row in gdf.dropna(\n",
        "    subset=[\"latitude\", \"longitude\", \"minsk_geo_cluster_price\"]\n",
        ").iterrows():\n",
        "    color = colors[int(row[\"minsk_geo_cluster_price\"]) % len(colors)]\n",
        "    folium.CircleMarker(\n",
        "        location=[row[\"latitude\"], row[\"longitude\"]],\n",
        "        radius=4,\n",
        "        color=color,\n",
        "        fill=True,\n",
        "        fill_opacity=0.6,\n",
        "    ).add_to(m)\n",
        "\n",
        "# Добавим легенду\n",
        "legend_html = (\n",
        "    \"\"\"\n",
        "<div style=\"\n",
        "    position: fixed; \n",
        "    bottom: 50px; left: 50px; width: 160px; height: auto; \n",
        "    border:2px solid grey; z-index:9999; font-size:14px;\n",
        "    background-color:white; padding: 10px;\">\n",
        "<b>Кластеры</b><br>\n",
        "\"\"\"\n",
        "    + \"\".join(\n",
        "        f'<i style=\"background:{c};width:12px;height:12px;float:left;margin-right:8px\"></i>'\n",
        "        f\"Кластер {i}<br>\"\n",
        "        for i, c in enumerate(colors)\n",
        "    )\n",
        "    + \"</div>\"\n",
        ")\n",
        "\n",
        "m.get_root().html.add_child(folium.Element(legend_html))\n",
        "\n",
        "# Если вы в Jupyter\n",
        "m"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "04ef8fdd",
      "metadata": {},
      "source": [
        "Попробуем подход с кагла, где листья брались как кластера\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "76b1f81a",
      "metadata": {},
      "outputs": [],
      "source": [
        "from sklearn.tree import DecisionTreeRegressor\n",
        "from sklearn.ensemble import RandomForestRegressor\n",
        "\n",
        "tree = DecisionTreeRegressor(max_leaf_nodes=5, random_state=42)\n",
        "rf_tree = RandomForestRegressor(\n",
        "    n_estimators=100, max_leaf_nodes=5, random_state=42\n",
        ")\n",
        "tree.fit(gdf[[\"latitude\", \"longitude\"]], gdf[\"price_usd_per_m2\"])\n",
        "gdf[\"geo_cluster_tree_dtr\"] = tree.apply(gdf[[\"latitude\", \"longitude\"]])\n",
        "rf_tree.fit(gdf[[\"latitude\", \"longitude\"]], gdf[\"price_usd_per_m2\"])\n",
        "gdf[\"geo_cluster_rf\"] = (\n",
        "    rf_tree.apply(gdf[[\"latitude\", \"longitude\"]]).mean(axis=1).astype(int)\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "eada62ce",
      "metadata": {},
      "outputs": [],
      "source": [
        "# --- Подготовка данных ---\n",
        "gdf_valid = gdf.dropna(\n",
        "    subset=[\n",
        "        \"latitude\",\n",
        "        \"longitude\",\n",
        "        \"geo_cluster_tree_dtr\",\n",
        "        \"geo_cluster_rf\",\n",
        "        \"price_usd_per_m2\",\n",
        "    ]\n",
        ").copy()\n",
        "\n",
        "# --- Настройка карты ---\n",
        "center_minsk = [53.902334, 27.561879]\n",
        "m = folium.Map(location=center_minsk, zoom_start=11, tiles=\"cartodbpositron\")\n",
        "\n",
        "colors = [\n",
        "    \"red\",\n",
        "    \"blue\",\n",
        "    \"green\",\n",
        "    \"purple\",\n",
        "    \"orange\",\n",
        "    \"darkred\",\n",
        "    \"lightblue\",\n",
        "    \"darkgreen\",\n",
        "    \"pink\",\n",
        "    \"gray\",\n",
        "    \"cadetblue\",\n",
        "    \"lightgreen\",\n",
        "    \"darkpurple\",\n",
        "    \"beige\",\n",
        "]\n",
        "\n",
        "\n",
        "# --- Функция для добавления кластера на карту ---\n",
        "def add_clusters(gdf, cluster_col, map_obj, prefix=\"Cluster\"):\n",
        "    for _, row in gdf.iterrows():\n",
        "        color = colors[int(row[cluster_col]) % len(colors)]\n",
        "        folium.CircleMarker(\n",
        "            location=[row[\"latitude\"], row[\"longitude\"]],\n",
        "            radius=4,\n",
        "            color=color,\n",
        "            fill=True,\n",
        "            fill_opacity=0.6,\n",
        "            popup=(\n",
        "                f\"{prefix}: {int(row[cluster_col])}<br>\"\n",
        "                f\"Price: ${row['price_usd_per_m2']:.0f}/m²\"\n",
        "            ),\n",
        "        ).add_to(map_obj)\n",
        "\n",
        "\n",
        "# --- Добавляем DecisionTree кластеры ---\n",
        "add_clusters(gdf_valid, \"geo_cluster_tree_dtr\", m, prefix=\"DTR Cluster\")\n",
        "\n",
        "# --- Добавляем RandomForest кластеры ---\n",
        "# add_clusters(gdf_valid, \"geo_cluster_rf\", m, prefix=\"RF Cluster\")\n",
        "\n",
        "# --- Отображаем карту ---\n",
        "m"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "cce918e5",
      "metadata": {},
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "fdfb48b0",
      "metadata": {},
      "outputs": [],
      "source": [
        "cities = pd.read_json(\"./geo/belarus_cities.json\")\n",
        "cities"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "bdaba9cd",
      "metadata": {},
      "outputs": [],
      "source": [
        "from geopy.distance import geodesic\n",
        "\n",
        "\n",
        "def nearest_city_distance(row, cities_df, size_filter):\n",
        "    df = cities_df[cities_df[\"size\"] == size_filter]\n",
        "    distances = df.apply(\n",
        "        lambda x: geodesic(\n",
        "            (row[\"latitude\"], row[\"longitude\"]), (x[\"latitude\"], x[\"longitude\"])\n",
        "        ).km,\n",
        "        axis=1,\n",
        "    )\n",
        "    return distances.min()\n",
        "\n",
        "\n",
        "# Расстояния до разных категорий городов\n",
        "gdf[\"dist_to_capital_km\"] = gdf.apply(\n",
        "    lambda row: nearest_city_distance(row, cities, \"capital\"), axis=1\n",
        ")\n",
        "gdf[\"dist_to_big_city_km\"] = gdf.apply(\n",
        "    lambda row: nearest_city_distance(row, cities, \"big\"), axis=1\n",
        ")\n",
        "gdf[\"dist_to_medium_city_km\"] = gdf.apply(\n",
        "    lambda row: nearest_city_distance(row, cities, \"medium\"), axis=1\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "e6237b61",
      "metadata": {},
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "808ee7b6",
      "metadata": {},
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "markdown",
      "id": "abc4c701",
      "metadata": {},
      "source": [
        "## Save\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "8bec3002",
      "metadata": {},
      "outputs": [],
      "source": [
        "gdf.to_csv(\"./data/after_eda_with_geo.csv\", index=False)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "9c844756",
      "metadata": {},
      "source": [
        "# Start\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f74e725a",
      "metadata": {},
      "outputs": [],
      "source": [
        "df = pd.read_csv(\"./data/after_eda_with_geo.csv\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c025d2c8",
      "metadata": {},
      "outputs": [],
      "source": [
        "SHUFFLE = True\n",
        "TEST_SIZE = 0.25\n",
        "RANDOM_STATE = 42"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "470f07bb",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.sort_values(\"deal_date\", inplace=True)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b541e0ab",
      "metadata": {},
      "outputs": [],
      "source": [
        "TARGET = \"price_usd_per_m2\"\n",
        "TARGET_LOG = \"log1p_price_usd_per_m2\""
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "62bde79a",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.drop(\n",
        "    columns=[\"Адрес\", \"inventory_id\", \"deal_date\", \"geometry\", \n",
        "             'longitude', 'latitude'\n",
        "             ], inplace=True\n",
        ")\n",
        "\n",
        "Y = df[TARGET_LOG]\n",
        "X = df.drop(columns=[TARGET, TARGET_LOG])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "bb04b240",
      "metadata": {},
      "outputs": [],
      "source": [
        "df.columns"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "838417e0",
      "metadata": {},
      "outputs": [],
      "source": [
        "cat_cols = [\n",
        "    \"property_type\",\n",
        "    \"wall_material\",\n",
        "    \"transferred_share\",\n",
        "    \"category\",\n",
        "    \"for_clusters_gr\",\n",
        "    \"Name NP\",\n",
        "    \"region_name\",\n",
        "    \"oblast_name\",\n",
        "    \"cluster\",\n",
        "    \"minsk_geo_cluster_price\",\n",
        "    \"geo_cluster_tree_dtr\",\n",
        "    \"geo_cluster_rf\",\n",
        "]\n",
        "cat_idx = [X.columns.get_loc(c) for c in cat_cols]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "cbb6c5c7",
      "metadata": {},
      "outputs": [],
      "source": [
        "X_train, X_valid, y_train, y_valid = train_test_split(\n",
        "    X, Y, test_size=TEST_SIZE, random_state=RANDOM_STATE, shuffle=SHUFFLE\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5cab1750",
      "metadata": {},
      "outputs": [],
      "source": [
        "X_train[cat_cols] = X_train[cat_cols].astype(\"category\")\n",
        "X_valid[cat_cols] = X_valid[cat_cols].astype(\"category\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "ac504773",
      "metadata": {},
      "outputs": [],
      "source": [
        "best_params = {\n",
        "    \"boosting_type\": \"gbdt\",\n",
        "    \"colsample_bytree\": 0.6,\n",
        "    \"importance_type\": \"split\",\n",
        "    \"learning_rate\": 7e-4,\n",
        "    \"max_depth\": 8,\n",
        "    \"min_child_samples\": 11,\n",
        "    \"min_child_weight\": 4.175410890723387,\n",
        "    \"min_split_gain\": 0.01768422649000459,\n",
        "    \"n_estimators\": 100_000,\n",
        "    \"n_jobs\": 0,\n",
        "    \"num_leaves\": 63,\n",
        "    \"objective\": \"regression\",\n",
        "    \"random_state\": 42,\n",
        "    \"reg_alpha\": 2.3326872626500275,\n",
        "    \"reg_lambda\": 2,\n",
        "    \"subsample\": 0.8,\n",
        "    \"max_bin\": 249,\n",
        "    \"extra_trees\": False,\n",
        "    \"verbose\": -1,\n",
        "}"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "686120f2",
      "metadata": {},
      "outputs": [],
      "source": [
        "lgbm_model = LGBMRegressor(**best_params)\n",
        "differential_stopping = SimpleGapStopping(metric_name=\"rmse\", gap_threshold=1.5)\n",
        "\n",
        "lgbm_model.fit(\n",
        "    X_train,\n",
        "    y_train,\n",
        "    eval_set=[\n",
        "        (X_train, y_train),\n",
        "        (X_valid, y_valid),\n",
        "    ],\n",
        "    eval_metric=[\"rmse\"],\n",
        "    callbacks=[\n",
        "        early_stopping(\n",
        "            stopping_rounds=300,\n",
        "        ),\n",
        "        differential_stopping,\n",
        "        log_evaluation(200),\n",
        "    ],\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "ec0c40ef",
      "metadata": {},
      "outputs": [],
      "source": [
        "print(\n",
        "    \"Train\",\n",
        "    compute_metrics(np.expm1(y_train), np.expm1(lgbm_model.predict(X_train))),\n",
        ")\n",
        "print(\n",
        "    \"Valid\",\n",
        "    compute_metrics(np.expm1(y_valid), np.expm1(lgbm_model.predict(X_valid))),\n",
        ")\n",
        "# print(\n",
        "#     \"Train\",\n",
        "#     compute_metrics((y_train), (lgbm_model.predict(X_train))),\n",
        "# )\n",
        "# print(\n",
        "#     \"Valid\",\n",
        "#     compute_metrics((y_valid), (lgbm_model.predict(X_valid))),\n",
        "# )"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c71e5935",
      "metadata": {},
      "source": [
        "Train {'rmse': 182.22218331572515, 'mse': 33204.92409234974, 'mae': 99.77526838087483, 'r2': 0.8138773764097993, 'mape*%': 54.921415439943175, 'median_mape*%': np.float64(30.187685673525515), 'smape\\_%': np.float64(40.29108242636932)}\n",
        "\n",
        "Valid {'rmse': 224.63642690062161, 'mse': 50461.52429067832, 'mae': 127.38124689062357, 'r2': 0.7191830768680751, 'mape*%': 106.05473079617586, 'median_mape*%': np.float64(40.26021285910403), 'smape\\_%': np.float64(54.74223078693505)}\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "85a35c53",
      "metadata": {},
      "outputs": [],
      "source": [
        "explainer = shap.Explainer(\n",
        "    lgbm_model,\n",
        "    feature_perturbation=\"tree_path_dependent\",\n",
        ")\n",
        "shap_values = explainer(X_valid)\n",
        "shap.summary_plot(shap_values, X_valid, max_display=X_valid.shape[1])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "1a275610",
      "metadata": {},
      "outputs": [],
      "source": [
        "# results = []\n",
        "# X[cat_cols] = X[cat_cols].astype(\"category\")\n",
        "# # Один раз вычисляем exp\n",
        "# y_true_full = np.expm1(Y)\n",
        "# segment_cols = [\n",
        "#     \"property_type\",\n",
        "#     \"Name NP\",\n",
        "#     \"region_name\",\n",
        "#     \"wall_material\",\n",
        "#     \"cluster\",\n",
        "#     \"category\",\n",
        "#     \"floors_below\",\n",
        "#     \"for_clusters_gr\",\n",
        "#     \"oblast_name\",\n",
        "# ]\n",
        "\n",
        "# for col in segment_cols:\n",
        "#     for val in tqdm(X[col].unique(), desc=col):\n",
        "#         if pd.isna(val):\n",
        "#             mask = X[col].isna()  # выбираем все NaN\n",
        "#             segment_val = \"NaN\"\n",
        "#         else:\n",
        "#             mask = X[col] == val\n",
        "#             segment_val = val\n",
        "\n",
        "#         y_true = y_true_full[mask]\n",
        "#         X_seg = X.loc[mask]\n",
        "\n",
        "#         y_pred = np.expm1(lgbm_model.predict(X_seg))\n",
        "#         metrics = compute_metrics(y_true, y_pred)\n",
        "\n",
        "#         results.append(\n",
        "#             {\n",
        "#                 \"segment_col\": col,\n",
        "#                 \"segment_val\": segment_val,\n",
        "#                 \"n_samples\": len(X_seg),\n",
        "#                 **metrics,\n",
        "#             }\n",
        "#         )\n",
        "\n",
        "# results_df = pd.DataFrame(results)\n",
        "# print(results_df.shape)\n",
        "# results_df = results_df[results_df[\"n_samples\"] > 100]\n",
        "# print(results_df.shape)\n",
        "# metrics = [\"mae\", \"mape_%\", \"median_mape_%\", \"smape_%\"]\n",
        "\n",
        "# for segment_col in segment_cols:\n",
        "#     df_col = results_df[results_df[\"segment_col\"] == segment_col]\n",
        "\n",
        "#     # подписи с количеством сэмплов\n",
        "#     x_labels = [\n",
        "#         f\"{val}\\n(n={df_col[df_col['segment_val'] == val]['n_samples'].iloc[0]})\"\n",
        "#         for val in df_col[\"segment_val\"].unique()\n",
        "#     ]\n",
        "\n",
        "#     unique_vals = df_col[\"segment_val\"].unique()\n",
        "#     colors = sns.color_palette(\"tab20\", n_colors=len(unique_vals))\n",
        "#     palette = dict(zip(unique_vals, colors))\n",
        "\n",
        "#     fig, axes = plt.subplots(1, len(metrics), figsize=(19 * len(metrics), 8))\n",
        "\n",
        "#     if len(metrics) == 1:\n",
        "#         axes = [axes]\n",
        "\n",
        "#     for col_idx, metric in enumerate(metrics):\n",
        "#         ax = axes[col_idx]\n",
        "#         sns.barplot(\n",
        "#             data=df_col,\n",
        "#             x=\"segment_val\",\n",
        "#             y=metric,\n",
        "#             hue=\"segment_val\",\n",
        "#             palette=palette,\n",
        "#             dodge=False,\n",
        "#             ax=ax,\n",
        "#         )\n",
        "#         ax.set_title(f\"{segment_col} – {metric.upper()}\")\n",
        "#         ax.set_xticks(np.arange(len(x_labels)))\n",
        "#         ax.set_xticklabels(x_labels, rotation=45)\n",
        "\n",
        "#     fig.suptitle(f\"Метрики для сегмента {segment_col}\", fontsize=16)\n",
        "#     plt.subplots_adjust(top=0.85)\n",
        "# plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "6b1640b2",
      "metadata": {},
      "outputs": [],
      "source": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.13.0"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}
