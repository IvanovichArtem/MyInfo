updated_df = df.copy()

# Определяем уникальные id и создаём словарь для хранения диапазонов дат
unique_ids = df['id'].unique()
date_ranges = {id: pd.date_range(df.loc[df['id'] == id, 'dt'].min(), 
                                 df.loc[df['id'] == id, 'dt'].max(), 
                                 freq='MS') 
               for id in unique_ids}

# Создаём DataFrame с индивидуальными диапазонами дат
full_df = pd.concat([pd.DataFrame({'id': id, 'dt': dates}) for id, dates in date_ranges.items()], ignore_index=True)

# Объединяем с оригинальным DataFrame
merged_df = full_df.merge(df, on=['id', 'dt'], how='left')

# Заполняем пропущенные значения нулями для финансовых столбцов
for col in ['Задолженность', 'Резерв', 'Выдано', 'Сумма миграции']:
    merged_df[col] = merged_df[col].fillna(0)

# Заполняем столбцы CY, bucket_NPL и RG шифтом предыдущего значения
for col in ['CY', 'bucket_NPL', 'RG']:
    merged_df[col] = merged_df.groupby('id')[col].fillna(method='ffill')

# Рассчитываем "Погашено" на основе предыдущей задолженности
merged_df['Погашено'] = merged_df.groupby('id')['Задолженность'].shift(1).fillna(0)

# Финальный результат
updated_df = merged_df
